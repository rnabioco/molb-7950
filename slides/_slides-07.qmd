---
title: "R Bootcamp - Day 6"
subtitle: "Advanced data manipulation"
author: "{{< var instructor.block.bootcamp-r >}}"
---

```{r}
#| include: false
library(tidyverse)
library(here)
```

## Class 6 outline

* Advanced `mutate()` with conditional logic
* String manipulation with `stringr`
* Factor operations with `forcats`
* Complex data reshaping patterns
* Advanced summarizing with `across()`

# Advanced `mutate()` operations

## Conditional logic with `case_when()` {.smaller}

`case_when()` creates new variables based on multiple conditions.

```{r}
#| echo: true
#| output-location: column-fragment
library(palmerpenguins)
penguins |>
  mutate(
    size_category = case_when(
      body_mass_g < 3500 ~ "small",
      body_mass_g < 4500 ~ "medium",
      body_mass_g >= 4500 ~ "large",
      .default = NA_character_
    )
  ) |>
  select(species, body_mass_g, size_category)
```

---

Multiple conditions with `case_when()`

```{r}
#| echo: true
#| output-location: column-fragment
penguins |>
  mutate(
    description = case_when(
      species == "Adelie" & island == "Torgersen" ~ "Adelie from Torgersen",
      species == "Adelie" ~ "Other Adelie",
      flipper_length_mm > 200 ~ "Large flipper",
      .default = "Standard penguin"
    )
  ) |>
  count(description)
```

## Creating multiple variables with `mutate()`

```{r}
#| echo: true
#| output-location: column-fragment
penguins |>
  mutate(
    flipper_cm = flipper_length_mm / 10,
    body_mass_kg = body_mass_g / 1000,
    bill_ratio = bill_length_mm / bill_depth_mm,
    .keep = "used"
  )
```

# String operations

## Combining strings with `str_c()`

```{r}
#| echo: true
#| output-location: column-fragment
penguins |>
  mutate(
    id = str_c(species, island, sep = "_"),
    label = str_c(species, " (", year, ")")
  ) |>
  select(species, island, year, id, label)
```

## Splitting strings with `str_split()`

```{r}
#| echo: true
#| output-location: column-fragment
# create some sample data
sample_ids <- c("gene_1_treatment", "gene_2_control", "gene_3_treatment")

tibble(sample_id = sample_ids) |>
  mutate(
    split_parts = str_split(sample_id, "_"),
    gene_part = map_chr(split_parts, ~ .x[1]),
    number_part = map_chr(split_parts, ~ .x[2]),
    condition = map_chr(split_parts, ~ .x[3])
  ) |>
  select(-split_parts)
```

---

Using `separate_wider_delim()` for splitting

```{r}
#| echo: true
#| output-location: column-fragment
tibble(sample_id = sample_ids) |>
  separate_wider_delim(
    sample_id,
    delim = "_",
    names = c("gene", "number", "condition")
  )
```

## Detecting patterns with `str_detect()`

```{r}
#| echo: true
#| output-location: column-fragment
penguins |>
  mutate(
    has_e = str_detect(species, "e"),
    species_length = str_length(species)
  ) |>
  count(species, has_e, species_length)
```

# Factor operations

## Counting factor levels with `fct_count()`

```{r}
#| echo: true
#| output-location: column-fragment
fct_count(penguins$species)
```

```{r}
#| echo: true
#| output-location: column-fragment
# equivalent with dplyr
penguins |>
  count(species)
```

## Reordering factors with `fct_reorder()`

```{r}
#| echo: true
#| output-location: column-fragment
#| fig.alt: "Bar plot showing penguin species counts, ordered by frequency from lowest to highest"
penguins |>
  mutate(
    species = fct_reorder(species, body_mass_g, .fun = mean, na.rm = TRUE)
  ) |>
  ggplot(aes(x = species, y = body_mass_g)) +
  geom_boxplot() +
  theme_minimal()
```

## Lumping infrequent levels with `fct_lump()`

```{r}
#| echo: true
#| output-location: column-fragment
# create some sample data with many levels
sample_data <- tibble(
  category = sample(
    letters[1:10],
    100,
    replace = TRUE,
    prob = c(0.3, 0.25, 0.15, rep(0.03, 7))
  )
)

sample_data |>
  mutate(
    lumped = fct_lump_n(category, n = 3)
  ) |>
  count(lumped, sort = TRUE)
```

# Complex data reshaping

## Advanced pivoting patterns

```{r}
#| echo: true
#| output-location: column-fragment
# simulate some genomics data
gene_data <- tibble(
  gene_id = rep(c("gene1", "gene2"), each = 4),
  sample_id = rep(c("ctrl_rep1", "ctrl_rep2", "treat_rep1", "treat_rep2"), 2),
  expression = c(10, 12, 15, 18, 8, 9, 20, 22)
)

gene_data
```

---

Reshaping to wide format, then back to long

```{r}
#| echo: true
#| output-location: column-fragment
wide_data <- gene_data |>
  pivot_wider(
    names_from = sample_id,
    values_from = expression
  )

wide_data
```

```{r}
#| echo: true
#| output-location: column-fragment
wide_data |>
  pivot_longer(
    cols = -gene_id,
    names_to = "sample_id",
    values_to = "expression"
  )
```

# Advanced summarizing

## Using `across()` for multiple operations

```{r}
#| echo: true
#| output-location: column-fragment
penguins |>
  group_by(species) |>
  summarise(
    across(
      c(bill_length_mm, bill_depth_mm, flipper_length_mm),
      list(mean = ~ mean(.x, na.rm = TRUE), sd = ~ sd(.x, na.rm = TRUE))
    ),
    .groups = "drop"
  )
```

## Counting with logical conditions

```{r}
#| echo: true
#| output-location: column-fragment
penguins |>
  group_by(species) |>
  summarise(
    total_count = n(),
    large_flipper_count = sum(flipper_length_mm > 200, na.rm = TRUE),
    prop_large_flipper = mean(flipper_length_mm > 200, na.rm = TRUE),
    missing_body_mass = sum(is.na(body_mass_g)),
    .groups = "drop"
  )
```

## Complex grouping and summarizing

```{r}
#| echo: true
#| output-location: column-fragment
penguins |>
  group_by(species, island) |>
  summarise(
    n_penguins = n(),
    avg_mass = mean(body_mass_g, na.rm = TRUE),
    max_flipper = max(flipper_length_mm, na.rm = TRUE),
    .groups = "drop"
  ) |>
  arrange(desc(avg_mass))
```

# Joining data frames

## Understanding joins

Joins combine data from two tables based on matching keys.

```{r}
#| echo: true
# Sample data for demonstration
band_members <- tribble(
  ~name,    ~band,
  "Mick",   "Stones",
  "John",   "Beatles",
  "Paul",   "Beatles"
)

band_instruments <- tribble(
  ~name,    ~plays,
  "John",   "guitar",
  "Paul",   "bass",
  "Keith",  "guitar"
)
```

## `left_join()` - keep all rows from left table

```{r}
#| echo: true
#| output-location: column-fragment
band_members |>
  left_join(band_instruments, by = "name")
```

Most common join - keeps all observations from the "primary" table.

## `inner_join()` - keep only matching rows

```{r}
#| echo: true
#| output-location: column-fragment
band_members |>
  inner_join(band_instruments, by = "name")
```

Only keeps rows that exist in both tables.

## `full_join()` - keep all rows from both tables

```{r}
#| echo: true
#| output-location: column-fragment
band_members |>
  full_join(band_instruments, by = "name")
```

Keeps everything, filling missing values with `NA`.

# Data quality and cleaning

## Handling missing data

```{r}
#| echo: true
#| output-location: column-fragment
penguins |>
  # identify rows with missing values
  mutate(
    has_missing = if_any(everything(), is.na)
  ) |>
  count(has_missing)
```

```{r}
#| echo: true
#| output-location: column-fragment
# remove rows with missing values in specific columns
penguins |>
  drop_na(bill_length_mm, body_mass_g) |>
  nrow()
```

## Summary

- `case_when()` for complex conditional logic
- `stringr` functions for text manipulation
- `forcats` functions for factor operations
- Advanced pivoting and reshaping patterns
- `across()` for applying functions to multiple columns
- Data quality checks and cleaning techniques

These concepts prepare you for the more complex data manipulation tasks in upcoming problem sets.
