---
title: "Factor-centric chromatin analysis"
author: "{{< var instructor.block.dna >}}"
---

## Where do transcription factors bind in the genome?

Today we'll look at where two yeast transcription factors bind in the genome using CUT&RUN.

## Where do transcription factors bind in the genome?

Techniques like CUT&RUN require an affinity reagent (e.g., an antibody) that uniquely recognizes a transcription factor in the cell.

This antibody is added to permeabilized cells, and the antibody associates with the epitope. A separate reagent, a fusion of Protein A (which binds IgG) and micrococcal nuclease (MNase) then associates with the antibody. Addition of calcium activates MNase, and nearby DNA is digested. These DNA fragments are then isolated and sequenced to identify sites of TF association in the genome.

## Where do transcription factors bind in the genome?

![Fig 1a, Skene et al.](../img/block-dna/skene-fig-1a.png)

## Data download and pre-processing

CUT&RUN data were downloaded from the [NCBI GEO page](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE84474) for Skene et al.

I selected the 16 second time point for *S. cerevisiae* Abf1 and Reb1 (note the paper combined data from the 1-32 second time points).

BED files containing mapped DNA fragments were separated by size and converted to bigWig with:

``` bash
# separate fragments by size
awk '($3 - $2 <= 120)' Abf1.bed > CutRun_Abf1_lt120.bed
awk '($3 - $2 => 150)' Abf1.bed > CutRun_Abf1_gt150.bed

# for each file with the different sizes
bedtools genomecov -i Abf1.bed -g sacCer3.chrom.sizes -bg > Abf1.bg
bedGraphToBigWig Abf1.bg sacCer3.chrom.sizes Abf1.bw
```

The bigWig files are available here in the `data/` directory.

# CUT&RUN analysis

```{r}
#| label: load-libs
#| message: false
library(tidyverse)
library(here)
library(valr)

# genome viz
library(TxDb.Scerevisiae.UCSC.sacCer3.sgdGene)
library(Gviz)
library(rtracklayer)

# motif discovery and viz
library(BSgenome.Scerevisiae.UCSC.sacCer3)
library(motifRG)
library(seqLogo)
```



```{r}
#| label: make-tracks
track_start <- 90000
track_end <- 150000

# genes track
sgd_genes_trk <-
  GeneRegionTrack(
    TxDb.Scerevisiae.UCSC.sacCer3.sgdGene,
    chromosome = "chrII",
    start = track_start,
    end = track_end,
    background.title = "white",
    col.title = "black",
    fontsize = 16
  )

# signal tracks
track_info <-
  tibble(
    file_name = c(
      "CutRun_Reb1_lt120.bw",
      "CutRun_Abf1_lt120.bw",
      "CutRun_Reb1_gt150.bw",
      "CutRun_Abf1_gt150.bw"
    ),
    sample_type = c(
      "Reb1_Short",
      "Abf1_Short",
      "Reb1_Long",
      "Abf1_Long"
    )
  ) |>
  mutate(
    file_path = here("data/block-dna", file_name),
    big_wig = purrr::map(
      file_path,
      ~ import.bw(.x, as = "GRanges")
    ),
    data_track = purrr::map2(
      big_wig,
      sample_type,
      ~ DataTrack(
        .x,
        name = .y,
        background.title = "white",
        col.title = "black",
        col.axis = "black",
        fontsize = 16
      )
    )
  ) |>
  dplyr::select(sample_type, big_wig, data_track)

# x-axis track
x_axis_trk <- GenomeAxisTrack(
  col = "black",
  col.axis = "black",
  fontsize = 16
)
```


```{r}
#| label: plot-tracks
plotTracks(
  c(
    sgd_genes_trk,
    track_info$data_track,
    x_axis_trk
  ),
  from = track_start,
  to = track_end,
  chromosome = "chrII",
  transcriptAnnotation = "gene",
  shape = "arrow",
  type = "histogram"
)
abf1_tbl <- read_bigwig(here("data/block-dna/CutRun_Abf1_lt120.bw"))
total_reads <- 16e6

genome <- read_genome(here("data/block-dna/sacCer3.chrom.sizes"))
genome_size <- sum(genome$size)

genome_lambda <- total_reads / genome_size
peak_calls <-
  abf1_tbl |>
  # define single-base sites
  mutate(
    midpoint = start + round((end - start) / 2),
    start = midpoint,
    end = start + 1,
    # use the poisson to calculate a p-value with the genome-wide lambda
    pval = dpois(score, genome_lambda),
    # convert p-values to FDR
    fdr = p.adjust(pval, method = "fdr")
  )

peak_calls_sig <-
  filter(
    peak_calls,
    fdr == 0
  ) |>
  # collapse neighboring, significant sites
  bed_merge(max_dist = 20)

filter(
  peak_calls_sig,
  chrom == "chrII" &
    start >= track_start &
    end <= track_end
)

peak_calls_gr <-
  GRanges(
    seqnames = peak_calls_sig$chrom,
    ranges = IRanges(peak_calls_sig$start, peak_calls_sig$end)
  )
```

## How do proteins recognize specific locations in the genome to bind?

## Motif discovery

## Theory

There are two major approaches to defining sequence motifs enriched in a sample: enumerative and probabilistic approaches.

## Theory

Here we'll apply a probabilistic approach (motifRG) to discover motifs in a collection of DNA sequences. During the RNA block, you'll learn about k-mer analysis, which is a form of enumerative approach.

In each case, the goal is to define a set of sequence motifs that are encriched in a set of provided sequences (i.e., peaks from CUT&RUN data) relative to a genomic background.

## Theory

Motifs are expressed in a [Position Weight Matrix](https://en.wikipedia.org/wiki/Position_weight_matrix), which captures the propensities for a position to be a particular nucleotide in a sequence motif.

These PWMs can be represented as sequence logos, visually represent the amount of information provided by the motif, typically using "information content", expressed in bits.

## Theory
![LexA sequence motif](../img/block-dna/lexa-motif.png)

## Practice

We'll use the [motifRG](https://bioconductor.org/packages/release/bioc/html/motifRG.html) package from Bioconductor to derive sequence motifs from the peaks we called above. This is a straightforward process:

1.  Collect the DNA sequences within the peak windows using the BSgenome for *S. cerevisiae*
2.  Provide those sequences to `motifRG::findMotif()`, which implements a Gibbs sampling approach to identify and refine motifs.
3.  Examine the discovered motifs, and plot as a logo using `seqLogo::seqLogo()`.

```{r}
#| label: motif-discovery
#| echo: true

peak_seqs <- BSgenome::getSeq(
  # provided by BSgenome.Scerevisiae.UCSC.sacCer3
  Scerevisiae,
  peak_calls_gr
) |>
  as.character()

# takes ~2 minutes to run
motif_results <- findMotif(
  sequences = peak_seqs,
  len = c(6, 8, 10, 12), # motif lengths to search
  numMotif = 5, # number of motifs to find
  strand = "both" # search both strands
)

# look at the consensus motifs
motif_results$consensus

# how many consensus motifs are there?
motif_results$numOccur
```

Now let's look at the sequence logo for the top hit.

```{r}
#| label: plot-logo
#| echo: true
pwm <- motif_results$pwm[[1]]

seqLogo::seqLogo(pwm)
```

## Questions

1.  Does this motif make sense, based on what you know about the requirements and specificity of DNA binding by transcription factors?

2.  How might you confirm that a specific sequence (that conforms to a motif) is bound directly by a transcription factor?

## References

GADEM: a genetic algorithm guided formation of spaced dyads coupled with an EM algorithm for motif discovery. J Comput Biol 2009 \[[PMC free article](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2756050/)\] \[[PubMed](https://pubmed.ncbi.nlm.nih.gov/19193149)\] \[[Google Scholar](https://scholar.google.com/scholar_lookup?journal=J+Comput+Biol&title=GADEM:+a+genetic+algorithm+guided+formation+of+spaced+dyads+coupled+with+an+EM+algorithm+for+motif+discovery&author=L.+Li&volume=16&issue=2&publication_year=2009&pages=317-329&pmid=19193149&)\]
