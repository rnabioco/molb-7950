{
  "hash": "ff8500d261f7b56e10e2e63f1052e225",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Stats Bootcamp - class 15\"\nsubtitle: \"Dealing with big data\"\nauthor: \"{{< var instructor.block.bootcamp-stats >}}\"\neditor: visual\n---\n\n\n\n## Learning objectives\n\n-   Types of error and multiple test corrections\n-   Exploratory data analysis\n-   Clustering and overlaps\n\n## Types I and II error\n\nFalse positives and False negatives\n\n![](https://www.scribbr.com/wp-content/uploads/2021/01/type-i-and-ii-error-2.png)\n\n$\\alpha$ - significance level OR evidentiary standard\n\n$\\beta$ - type II error rate, 1 - $\\beta$ is power\n\n## Different visualization\n\nPower vs Significance\n\n![](https://www.scribbr.com/wp-content/uploads/2021/01/type-i-and-type-ii-error.png)\n\n## Genomics -\\> Lots of Data -\\> Lots of Hypothesis Tests\n\nIn a typical RNA-seq experiment, we test \\~10K different hypotheses. For example, you have 10K genes and for each gene you test whether the mean expression changed in condition A vs condition B. Using a standard p-value cut-off of 0.05, we'd expect **500 genes** to be deemed \"significant\" by chance. Thus, we are very concerned about **False Positives or Type I Errors**.\n\n## Multiple test corrections {.smaller}\n\n1.  Control overall α (also known as family-wise error rate or [FWER](https://en.wikipedia.org/wiki/Family-wise_error_rate)), which will affect the α\\* for each test. That is, we are controlling the overall probability of making *at least one* false discovery. Bonferroni and Sidak corrections all control FWER.\n\n2.  Control [false discovery rate](https://en.wikipedia.org/wiki/False_discovery_rate) (FDR). These procedures allow for type 1 errors (false positives) but control the proportion of these false positives in relation to true positives. This is done by adjusting the decision made for the p-value associated with each individual test to decide rejection or not. Because this will result in a higher type 1 error rate, it has higher [power](https://en.wikipedia.org/wiki/Power_(statistics)). This affords a higher probability of *true discoveries.* The step procedures control for FDR.\n\n## Bonferroni Correction {.smaller}\n\nThe most conservative of corrections, the Bonferroni correction is also perhaps the most straightforward in its approach. Simply divide α by the number of tests (*m*).\n\n> α = α/m\n\nHowever, with many tests, α will become very small. This reduces power, which means that we are very unlikely to make any true discoveries.\n\n### Sidak Correction\n\n> α = 1-(1-α)\\^(1/*m*)\n\n## Holm's Step-Down Procedure {.smaller}\n\nThe Holm-Bonferroni method is also fairly simple to calculate, but it is more powerful than the single-step Bonferroni.\n\n$HB = \\displaystyle \\frac {target \\alpha}{n - rank + 1}$\n\nH1: 0.005\\\nH2: 0.01\\\nH3: 0.03\\\nH4: = 0.04\\\n\nStep 1: Order the p-values from smallest to greatest (already done)\n\nStep 2: Calc HB for the first rank HB = .05 / 4 -- 1 + 1 = .05 / 4 = .0125 H1: 0.005 \\< .0125, so we reject the null\n\nStep 4: Repeat the HB formula for the second rank and keep going until we find $H{_N}$ \\> $HB{_N}$. All subsequent hypotheses are non-significant (i.e. not rejected).\n\n## Hochberg's Step-Up Procedure {.smaller}\n\nMore powerful than Holm's step-down procedure, Hochberg's step-up procedure also seeks to control the FDR and follows a similar process, only p-values are ranked from largest to smallest.\n\nFor each ranked p-value, it is compared to the α calculated for its respective rank (same formula as Holm's procedure). Testing continues until you reach the first non-rejected hypothesis. You would then fail to reject all following hypotheses.\n\n## Example {.smaller}\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\nrna <- read_csv(here(\"data/bootcamp/data_rna_protein.csv.gz\")) |> select(iDUX4_pval)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 21282 Columns: 17\n── Column specification ────────────────────────────────────\nDelimiter: \",\"\nchr  (1): geneid\ndbl (16): iDUX4_logFC, iDUX4_logCPM, iDUX4_LR, iDUX4_pva...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nrna$fdr <- p.adjust(p = rna$iDUX4_pval, method = \"fdr\", n = nrow(rna))\nrna$BH <- p.adjust(p = rna$iDUX4_pval, method = \"BH\", n = nrow(rna))\nrna$bon <- p.adjust(p = rna$iDUX4_pval, method = \"bonferroni\", n = nrow(rna))\nrna_long <- rna |> pivot_longer(cols = iDUX4_pval:bon, names_to = \"type\")\n\nggplot(data = rna_long, aes(x = value, fill = type)) +\n  geom_histogram(bins = 50) +\n  facet_wrap(~type) +\n  theme_cowplot()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 35800 rows containing non-finite outside the scale\nrange (`stat_bin()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](slides-15_files/figure-revealjs/unnamed-chunk-2-1.png){width=960}\n:::\n:::\n\n\n## Exploratory data analysis (EDA) {.smaller}\n\nOur goal here is to get an top-down big picture of the similarity/differences between variables in a dataset. For example, let's say you do RNA-seq in triplicate on 4 treatment/developmental times.\n\n### PCA\n\nWe will perform PCA on all of the samples and visualize the relationship between samples.\n\n### Correlation matrix\n\nWe will perform hierarchical clustering on a matrix representing the pairwise correlation between all these samples.\n\n## Explore data {.smaller}\n\nIs it normal-ish?\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# get dux targets\ndux_targets <- read_csv(file = here(\"data\", \"target_genes.csv.gz\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 74 Columns: 1\n── Column specification ────────────────────────────────────\nDelimiter: \",\"\nchr (1): hgnc_symbol\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nd <- read_tsv(here(\"data\", \"data_genelevel.tsv.gz\")) |>\n  mutate(target = case_when(\n    gene_symbol %in% dux_targets$hgnc_symbol ~ \"target\",\n    TRUE ~ \"not_target\"\n  )) |>\n  filter(gene_symbol != \"ISCA1\") |>\n  drop_na()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 10568 Columns: 13\n── Column specification ────────────────────────────────────\nDelimiter: \"\\t\"\nchr  (1): gene_symbol\ndbl (12): hour00_rep1, hour00_rep2, hour00_rep3, hour04_...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nd |>\n  pivot_longer(cols = hour00_rep1:hour14_rep3) |>\n  ggplot(aes(x = value, color = name)) +\n  geom_density() +\n  theme_cowplot()\n```\n\n::: {.cell-output-display}\n![](slides-15_files/figure-revealjs/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n. . .\n\nDefinitely not normal\n\n## Data transformations {.smaller}\n\nWe often transform data to make it closer to being normally-distributed. This allows us to use more powerful statistical tests on the same data. One approach is to log-transform the data.\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nd |>\n  pivot_longer(cols = hour00_rep1:hour14_rep3) |>\n  ggplot(aes(x = log10(value), color = name)) +\n  geom_density() +\n  theme_cowplot()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 1239 rows containing non-finite outside the scale\nrange (`stat_density()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](slides-15_files/figure-revealjs/unnamed-chunk-4-1.png){width=960}\n:::\n:::\n\n\n. . .\n\nWhat is this?\n\n> Warning message: Removed 1251 rows containing non-finite values (stat_density()).\n\n## Pseudocounts {.smaller}\n\n$log_{x}(0)$ is a common problem. One solution is to add a pseudocount. Since this is read count data, the smallest unit is 1 and so we will add 1 to all the observations before perforing the log transformation. $1$ represents the pseudocount in this case.\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nd |>\n  pivot_longer(cols = hour00_rep1:hour14_rep3) |>\n  ggplot(aes(x = log10(value + 1), color = name)) +\n  geom_density() +\n  theme_cowplot()\n```\n\n::: {.cell-output-display}\n![](slides-15_files/figure-revealjs/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n## correlation analysis\n\nprepare the data for analysis\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\n# pull counts\nx <- d |>\n  select_if(is.numeric) |> # keep only the numeric columns\n  mutate_all(funs(log2(1 + .))) |> # log2 transform\n  as.matrix() # matrix\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `funs()` was deprecated in dplyr 0.8.0.\nℹ Please use a list of either functions or lambdas:\n\n# Simple named list: list(mean = mean, median = median)\n\n# Auto named with `tibble::lst()`: tibble::lst(mean,\n  median)\n\n# Using lambdas list(~ mean(., trim = .2), ~ median(.,\n  na.rm = TRUE))\n```\n\n\n:::\n\n```{.r .cell-code}\nrownames(x) <- d$gene_symbol\n\n\nx <- t(scale(t(x)))\n\n\n# pairwise pearson correlation\np <- cor(x, method = \"pearson\")\n\npheatmap(\n  mat = p,\n  clustering_distance_rows = \"euclidean\",\n  clustering_distance_cols = \"euclidean\",\n  clustering_method = \"ward.D2\"\n)\n```\n\n::: {.cell-output-display}\n![](slides-15_files/figure-revealjs/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n\n## PCA\n\nPCA is a common dimensionality reduction method that is used to visualize the similarity and differences in your data.\n\n**Let's watch this fantastic 5 minute video explaining PCA**\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/HMOI_lkzW08\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen>\n\n</iframe>\n\nFor more detailed explanations go [here](https://www.nature.com/articles/nbt0308-303) and [here](https://liorpachter.wordpress.com/2014/05/26/what-is-principal-component-analysis/).\n\n## PCA\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# pairwise pearson correlation\npc <- prcomp(x)\n\nsummary(pc) # summarize the PCs by variance\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nImportance of components:\n                          PC1    PC2     PC3     PC4\nStandard deviation     2.3743 1.2799 0.79753 0.64825\nProportion of Variance 0.5739 0.1668 0.06475 0.04278\nCumulative Proportion  0.5739 0.7407 0.80544 0.84822\n                           PC5     PC6     PC7    PC8\nStandard deviation     0.53023 0.47044 0.46316 0.4541\nProportion of Variance 0.02862 0.02253 0.02184 0.0210\nCumulative Proportion  0.87684 0.89937 0.92121 0.9422\n                           PC9    PC10   PC11      PC12\nStandard deviation     0.44316 0.43982 0.4217 7.512e-15\nProportion of Variance 0.01999 0.01969 0.0181 0.000e+00\nCumulative Proportion  0.96221 0.98190 1.0000 1.000e+00\n```\n\n\n:::\n:::\n\n\n## PCA - prepare visualization\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\n# create a dataframe with the importance/explanation of variation for each PC\npca_data_info <- summary(pc)$importance |> as.data.frame()\n\npca_data_info <- round(x = pca_data_info, digits = 3)\n\n# we make a dataframe out of the rotations and will use this to plot\npca_plot_data <- pc$rotation |>\n  as.data.frame() |>\n  rownames_to_column(var = \"ID\") |>\n  separate(col = ID, into = c(\"time\", \"rep\"), sep = \"_\")\n\n# recode \"rep\"\npca_plot_data$rep <- recode(pca_plot_data$rep,\n  rep1 = \"A\",\n  rep2 = \"B\",\n  rep3 = \"C\"\n)\n\n# gsub hour\npca_plot_data$time <- gsub(\n  pattern = \"hour\",\n  replacement = \"\",\n  x = pca_plot_data$time\n)\n\nggplot(data = pca_plot_data, mapping = aes(x = PC1, y = PC2, color = time)) +\n  geom_point() +\n  xlab(paste(\"PC1, %\", 100 * pca_data_info[\"Proportion of Variance\", \"PC1\"])) +\n  ylab(paste(\"PC2, %\", 100 * pca_data_info[\"Proportion of Variance\", \"PC2\"])) +\n  ggtitle(\"PCA for DUX4 timecourse\") +\n  theme_cowplot()\n```\n\n::: {.cell-output-display}\n![](slides-15_files/figure-revealjs/unnamed-chunk-8-1.png){width=960}\n:::\n:::\n\n\n## Famous PCA example {.smaller}\n\nUsing gene expression as your measurement, do you think the mouse liver is more similar to a mouse heart or a human liver?\n\nThe Mouse ENCODE Consortium reported that comparative gene expression data from human and mouse tend to cluster more by species rather than by tissue.\n\n![](/img/bad_pca.jpg)\n\n[A comparative encyclopedia of DNA elements in the mouse genome](https://www.nature.com/articles/nature13992)\n\n[Comparison of the transcriptional landscapes between human and mouse tissues](https://www.pnas.org/doi/full/10.1073/pnas.1413624111)\n\n## Some found this hard to believe {.smaller}\n\n[Yoav Gilad's lab recapitulated the initial result:](https://f1000research.com/articles/4-121#ref-1)\n\n![](/img/redo_encode.jpg)\n\nThis observation was surprising, as it contradicted much of the comparative gene regulatory data collected previously, as well as the common notion that major developmental pathways are highly conserved across a wide range of species, in particular across mammals.\n\n## Careful with batch effects {.smaller}\n\nBut noticed something funny about which samples were sequenced on the same lanes.\n\n![](/img/batch.jpg)\n\n## Accounting for batch effects {.smaller}\n\n![](/img/fixencode.jpg)\n\nHere we show that the Mouse ENCODE gene expression data were collected using a flawed study design, which confounded sequencing batch (namely, the assignment of samples to sequencing flowcells and lanes) with species. When we account for the batch effect, the corrected comparative gene expression data from human and mouse tend to cluster by tissue, not by species.\n\n## K-means clustering to look for patterns {.smaller}\n\nGoal: to partition `n` observations into `k` clusters in which each observation belongs to the cluster with the nearest mean, serving as a prototype of the cluster. --Wiki\n\n**K-means** <iframe width=\"300\" height=\"150\" src=\"https://www.youtube.com/embed/4b5d3muPQmA\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n## K-Means data preparation {.smaller}\n\n1.  Rows are observations (individuals) and columns are variables\n2.  Any missing value in the data must be removed or estimated.\n3.  The data must be standardized (i.e., scaled) to make variables comparable.\n\n## Scaling or z-score {.smaller}\n\n![](http://www.z-table.com/uploads/2/1/7/9/21795380/1426878678.png){%20}\n\n$x$ = observation\\\n$\\mu$ = population mean\\\n$\\sigma$ = population sd\n\nWe will be using this function on each row. This will allow comparison of relative changes across a row, for all rows.\n\n## K-Means clustering\n\n1.  Computing k-means clustering in R (pheatmap)\n2.  Determine appropriate cluster number\n3.  Add new column with cluster number to initial data\n\n## How do we figure out the optimal \\# clusters?\n\nThere are many methods, but we will stick with the \"elbow\" method.\n\nK-means is minimizing the total within cluster sum of squares (wss).\n\nWe pick the cluster where that drop in total reaches diminishing returns -\\> the elbow.\n\n## Let's cluster once to see {.smaller}\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\nset.seed(33)\ntmp <- pheatmap(\n  mat = x,\n  clustering_distance_rows = \"euclidean\",\n  clustering_method = \"ward.D2\",\n  kmeans_k = 8,\n  cluster_cols = F,\n  scale = \"none\"\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Quick-TRANSfer stage steps exceeded maximum (=\n528300)\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](slides-15_files/figure-revealjs/unnamed-chunk-9-1.png){width=960}\n:::\n\n```{.r .cell-code}\ntmp$kmeans$tot.withinss\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 32071.65\n```\n\n\n:::\n:::\n\n\n## Functions in R {.smaller}\n\n![](https://www.learnbyexample.org/wp-content/uploads/r/r-function-syntax.png)\n\n## Create function to calculate wss {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwss <- function(knum) {\n  ph <- pheatmap(\n    mat = x,\n    kmeans_k = knum,\n    scale = \"none\",\n    cluster_cols = F,\n    clustering_distance_rows = \"euclidean\",\n    clustering_method = \"ward.D2\",\n    silent = T\n  )\n  return(ph$kmeans$tot.withinss)\n}\n\nwss(6)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 34318.06\n```\n\n\n:::\n:::\n\n\n## find the elbow {.smaller}\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ntibble(\n  wss = map_vec(2:15, wss),\n  k = 2:15\n) |>\n  ggplot(aes(x = k, y = wss)) +\n  geom_point() +\n  theme_cowplot()\n```\n\n::: {.cell-output-display}\n![](slides-15_files/figure-revealjs/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n\n\n## Final clustering {.smaller}\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nset.seed(33)\nc <- pheatmap(\n  mat = x,\n  clustering_distance_rows = \"euclidean\",\n  clustering_method = \"ward.D2\",\n  kmeans_k = 7,\n  cluster_cols = F,\n  scale = \"none\"\n)\n```\n\n::: {.cell-output-display}\n![](slides-15_files/figure-revealjs/unnamed-chunk-12-1.png){width=960}\n:::\n\n```{.r .cell-code}\ncg <- data.frame(\n  Cluster = c$kmeans$cluster,\n  gene_symbol = names(c$kmeans$cluster)\n)\n\ncd <- left_join(d, cg, by = \"gene_symbol\") |> as_tibble()\n\nwrite_tsv(cd, here(\"data\", \"dux4_clustering_results.csv.gz\"))\n```\n:::\n\n\n## Which cluster(s) contains DUX4 targets? {.smaller}\n\n[Fisher's Exact Test and the Hypergeometric Distribution](https://www.youtube.com/watch?v=udyAvvaMjfM)\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\n# list of genes by dux4 targeting\nduxList <- split(cd$gene_symbol, cd$target)\n\n# list of genes by clustering\nclustList <- split(cd$gene_symbol, as.factor(cd$Cluster))\n\n# calculate all overlaps between lists\ngom.duxclust <- newGOM(duxList,\n  clustList,\n  genome.size = nrow(d)\n)\n\n\ngetMatrix(gom.duxclust, \"pval\") |>\n  t() |>\n  as.data.frame() |>\n  rownames_to_column(var = \"clust\") |>\n  as.tibble() |>\n  arrange(target)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: `as.tibble()` was deprecated in tibble 2.0.0.\nℹ Please use `as_tibble()` instead.\nℹ The signature and semantics have changed, see\n  `?as_tibble`.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 3\n  clust not_target   target\n  <chr>      <dbl>    <dbl>\n1 5     1.00       2.59e-14\n2 6     1.00       1.57e- 5\n3 2     0.182      9.25e- 1\n4 4     0.0261     9.96e- 1\n5 1     0.000114   1.00e+ 0\n6 7     0.00000128 1.00e+ 0\n7 3     0.0107     1   e+ 0\n```\n\n\n:::\n:::\n\n\n## Let's calculate the empirical p-value of the cluster most enriched for DUX4 targets by sampling {.smaller}\n\nIn order to do this, you will need to:\n\n1.  Identify which cluster is the most enriched for DUX4 targets.\n    -   Determine how many genes are in the cluster. You will need to know this to figure out how many genes to sample from the whole data set.\n    -   Determine how many of the genes in the cluster are DUX4 targets. This is the metric that you are interested in comparing between the null distribution and your observation.\n2.  Generate 1000 random sample of the proper size from all genes and find out how many of them are DUX4 targets.\n3.  Visualize the distribution of DUX4 targets in these 1000 random (your null distribution) and overlay the number of DUX4 targets you observed in the cluster that was most enriched for DUX4 targets.\n",
    "supporting": [
      "slides-15_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}