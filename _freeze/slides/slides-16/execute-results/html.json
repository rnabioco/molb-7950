{
  "hash": "c8691e63f3614d64d1d6d9f9d97371b2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Mapping chromatin structure and transactions\"\nauthor: \"{{< var instructor.block.dna >}}\"\n---\n\n## Final Projects\n\nThroughout the DNA and RNA blocks will refer to several data sets that might be good starting points for your final project (worth 20% of your grade).\n\nWe will ask for a sketch of the rough plan for a final project by the end of week 7 (Fri Oct 11). In addition, if you plan to work in a group, we'd like to know who you will be working with.\n\n**Final projects will be due Friday Nov 3. We will schedule short (5 minute) talks by each group on Oct 28 and Oct 29.**\n\n::: nonincremental\n-   [Final project overview](https://rnabioco.github.io/molb-7950/course-info/final-projects.html)\n-   [DNA block resources](https://rnabioco.github.io/molb-7950/resources/block-dna-resources.html)\n:::\n\n## Gene regulation by chromatin\n\n::: {layout-ncol=\"3\" layout-valign=\"center\"}\n![Genome organization](../img/block-dna/ctcf.jpg)\n\n![Cell signaling](../img/block-dna/promoter.png)\n\n![Organism development](../img/block-dna/org-dev.jpg)\n:::\n\n## DNA accessibility drives all biochemical transactions on the genome\n\n::::: columns\n::: {.column width=\"50%\"}\n-   Transcription Initiation\n-   Transcription Elongation\n-   DNA Repair\n-   Initiation of DNA Replication\n-   Recombination\n-   Viral Integration\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/domino.gif)\n:::\n:::::\n\n## Mapping & measurement are first steps toward understanding. {.smaller}\n\n::::: columns\n::: {.column width=\"60%\"}\nBefore genome-wide DNA accessibility measurements, we knew about chromatin transactions at only a handful of loci.\n\nThis was a classic \"keys under the lamppost\" situation, leading to general models of chromatin-based gene regulation.\n:::\n\n::: {.column width=\"40%\"}\n![](../img/block-dna/street-lamp.jpg){width=\"100%\"}\n:::\n:::::\n\n::: aside\nPhoto by [Justus Menke](https://unsplash.com/@justusmenke?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/photos/PvQtCNm4teI?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n:::\n\n## Using micrococcal nuclease (MNase) to map chromatin {.smaller}\n\n::::: columns\n::: {.column .nonincremental width=\"50%\"}\n-   Micrococcal nuclease is an endo/exonuclease from *Staphylococcus aureus*\n-   Efficient, **multiple turnover** enzyme that digests accessible DNA (& RNA)\n-   Dependent on calcium (Ca2+)\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/mnase-overview.png){fig-align=\"center\"}\n:::\n:::::\n\n## Using ATAC to map chromatin {.smaller}\n\n::::: columns\n::: {.column .nonincremental width=\"50%\"}\n-   Tn5 transposase catalyzes \"cut-and-paste\" insertion of DNA into a target\n-   In ATAC (\"Assay for Transposase-Accessible Chromatin\"), the transposase enzymes are loaded with DNA sequencing adaptors (blue and red in the image), so the products of transposition are ready to PCR.\n-   **Single turnover enzyme** that acts on accessible DNA.\n-   Requires about \\~60 bp of accessible for transposition.\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/atac-explain.png){fig-align=\"center\"}\n:::\n:::::\n\n## **Chromatin mapping experimental summary** {.smaller}\n\n|   | DNase-seq | ATAC-seq | MNase-seq |\n|---------------|:-------------:|:---------------------------:|:-------------:|\n| **Genome representation** | Most active regions | Most active regions | Whole genome |\n| **Ease of experiment** | Very difficult | Easy peasy | One day's work |\n| **What is profiled?** | Accessible DNA, \"footprints\" at low cut frequency | Accessible DNA. Not really \"footprints\", single turnover enzyme, so fragments are not informative | Protections of TFs and nucleosomes |\n\n# Experimental details\n\n##\n\n![](../img/block-dna/footprinting-exp-overview.png)\n\n##\n\n![](../img/block-dna/atac-input-comparison.png)\n\n# Analysis details\n\n## Experimental workflow\n\n![](../img/block-dna/acc-workflow.png)\n\n# Data structures and tools used for analysis of chromatin mapping experiments\n\n## File formats\n\n### BED format {.smaller}\n\n::::: columns\n::: {.column .nonincremental width=\"50%\"}\n-   Contains information about genomic intervals.\n-   Used to represent genomic features (exons, introns, transcription start sites)\n-   First 3 columns are: `chrom`, `start`, `end`\n-   Next 3 are: `name`, `score`, `strand`. Strand can be `+`, `-`, or `.` (no strand)\n:::\n\n::: {.column width=\"50%\"}\n```\nchr7 127473530 127474697 Pos3 0  +\nchr7 127474697 127475864 Pos4 0  +\nchr7 127475864 127477031 Neg1 0  -\nchr7 127477031 127478198 Neg2 0  -\n```\n:::\n:::::\n\n------------------------------------------------------------------------\n\n### WIG / bedGraph {.smaller}\n\n::::: columns\n::: {.column .nonincremental width=\"50%\"}\n-   WIG and bedGraph store interval *signals*.\n\n    -   Genome sequencing coverage\n    -   Coverage of reads from MNase / ATAC-seq\n\n-   Many studies will provide genome-scale data in these formats\n:::\n\n::: {.column width=\"50%\"}\n```\nchr19 49302000 49302300 -1.0\nchr19 49302300 49302600 -0.75\nchr19 49302600 49302900 -0.50\nchr19 49302900 49303200 -0.25\n```\n:::\n:::::\n\n::: aside\nbigWig is a binary form of WIG, used to store large amounts of signal in a compressed, indexed format.\n:::\n\n## Interval analysis {.smaller}\n\n::::: columns\n::: {.column width=\"50%\"}\nThe primary tool in the genome interval analysis is [BEDtools](https://bedtools.readthedocs.io/en/latest/) -- it's the Swiss-army knife of internal analysis.\n\nWe wrote an R package called [valr](https://rnabioco.github.io/valr/) that provides the same tools, but you don't need to leave RStudio. valr provides the same tools for reading and manipulating genome intervals.\n\n`bed_intersect()` is a fundamental operation. It identifies intervals from two tibbles that intersect and reports their overlaps.\n\nLet's take a look at that it does.\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/intersect-glyph.png)\n:::\n:::::\n\n## `bed_intersect()` example {.smaller}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\nlibrary(valr)\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'dplyr'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n\n\n:::\n\n```{.r .cell-code}\nx <- tribble(\n  ~chrom, ~start, ~end,\n  \"chr1\", 25, 50,\n  \"chr1\", 100, 125\n)\n\ny <- tribble(\n  ~chrom, ~start, ~end,\n  \"chr1\", 30,     75\n)\n\nbed_intersect(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 6\n  chrom start.x end.x start.y end.y .overlap\n  <chr>   <dbl> <dbl>   <dbl> <dbl>    <int>\n1 chr1       25    50      30    75       20\n```\n\n\n:::\n:::\n\n\n## valr example\n\nYou can use `read_bed()` and related functions to load genome annotations and signals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(valr)\n\nsnps <- read_bed(\n  valr_example(\"hg19.snps147.chr22.bed.gz\"),\n  n_fields = 6\n)\n\ngenes <- read_bed(\n  valr_example(\"genes.hg19.chr22.bed.gz\"),\n  n_fields = 6\n)\n```\n:::\n\n\n::: aside\nWe'll also use the valr functions `read_bedgraph()` and `read_bigwig()`.\n:::\n\n## What is in `snps` and `genes`? {.smaller}\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\nhead(snps)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  chrom    start      end name        score strand\n  <chr>    <int>    <int> <chr>       <chr> <chr> \n1 chr22 16053247 16053248 rs587721086 0     +     \n2 chr22 16053443 16053444 rs80167676  0     +     \n3 chr22 16055964 16055965 rs587706951 0     +     \n4 chr22 16069373 16069374 rs2154787   0     +     \n5 chr22 16069782 16069783 rs1963212   0     +     \n6 chr22 16100513 16100514 rs8140563   0     +     \n```\n\n\n:::\n:::\n\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\nhead(genes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  chrom    start      end name      score strand\n  <chr>    <int>    <int> <chr>     <chr> <chr> \n1 chr22 16150259 16193004 AK022914  8     -     \n2 chr22 16162065 16172265 LINC00516 3     +     \n3 chr22 16179617 16181004 BC017398  1     -     \n4 chr22 16239287 16239327 DQ590589  1     +     \n5 chr22 16240245 16240277 DQ573684  1     -     \n6 chr22 16240300 16240340 DQ595048  1     -     \n```\n\n\n:::\n:::\n\n\n## Interval manipulation {.smaller}\n\nLet's find and characterize intergenic SNPs. We'll use the tools `bed_substract()` and `bed_closest()`. Take a look and their examples in the documentation to see what they do.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# find snps in intergenic regions\nintergenic <- bed_subtract(snps, genes)\n\n# find distance from intergenic snps to nearest gene\nnearby <- bed_closest(intergenic, genes)\n```\n:::\n\n\n. . .\n\nTake a look at the `intergenic` and `nearby` objects in the console.\n\n## Interval manipulation {.smaller}\n\nNow that you have overlaps and distances between SNPs and genes, you can go back to dplyr tools to generate reports.\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nnearby |>\n  select(\n    starts_with(\"name\"),\n    .overlap,\n    .dist\n  ) |>\n  filter(abs(.dist) < 5000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,047 × 4\n   name.x      name.y   .overlap .dist\n   <chr>       <chr>       <int> <int>\n 1 rs530458610 P704P           0  2579\n 2 rs2261631   P704P           0  -268\n 3 rs570770556 POTEH           0  -913\n 4 rs538163832 POTEH           0  -953\n 5 rs190224195 POTEH           0 -1399\n 6 rs2379966   DQ571479        0  4750\n 7 rs142687051 DQ571479        0  3558\n 8 rs528403095 DQ571479        0  3309\n 9 rs555126291 DQ571479        0  2745\n10 rs5747567   DQ571479        0 -1778\n# ℹ 1,037 more rows\n```\n\n\n:::\n:::\n\n\n## `bed_map()` example\n\n:::::: columns\n:::: {.column width=\"50%\"}\n`bed_map()` does two things in order:\n\n::: nonincremental\n1.  It identifies intersecting intervals between `x` and `y`\n2.  Calculates summary statistics based on the intersection\n:::\n\nA typical use is to count up signals (e.g., coverage from an MNase-seq experiment) over specific regions (e.g., promoter regions).\n::::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/map-glyph.png)\n:::\n::::::\n\n## `bed_map()` example {.smaller}\n\nCopy / paste these into your console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- tribble(\n  ~chrom, ~start, ~end,\n  \"chr1\", 100,    250,\n  \"chr2\", 250,    500\n)\n\ny <- tribble(\n  ~chrom, ~start, ~end, ~value,\n  \"chr1\", 100,    250,  10,\n  \"chr1\", 150,    250,  20,\n  \"chr2\", 250,    500,  500\n)\n```\n:::\n\n\n## `bed_map()` example continued {.smaller}\n\nFirst examine the intersecting intervals.\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nbed_intersect(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 7\n  chrom start.x end.x start.y end.y value.y .overlap\n  <chr>   <dbl> <dbl>   <dbl> <dbl>   <dbl>    <int>\n1 chr1      100   250     100   250      10      150\n2 chr1      100   250     150   250      20      100\n3 chr2      250   500     250   500     500      250\n```\n\n\n:::\n:::\n\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nbed_map(\n  x, y,\n  .sum = sum(value),\n  .count = length(value)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  chrom start   end  .sum .count\n  <chr> <dbl> <dbl> <dbl>  <int>\n1 chr1    100   250    30      2\n2 chr2    250   500   500      1\n```\n\n\n:::\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}