{
  "hash": "0c6472ec64108b4cf80d1f079a84b175",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Mapping chromatin structure and transactions\"\nauthor: \"{{< var instructor.block.dna >}}\"\ndate: last-modified\n---\n\n## Final Projects\n\nThroughout the DNA and RNA blocks we will refer to several data sets that might\nbe good starting points for your final project (worth 20% of your grade).\n\nWe will ask for a sketch of the rough plan for a final project by the end of\nweek 7 (Wed Oct 8). In addition, if you plan to work in a group, we'd like\nto know who you will be working with.\n\n**Final projects will be due Monday Oct 27. We will schedule short (5 minute) talks by each group on Oct 27 and Oct 29.**\n\n::: nonincremental\n-   [Final project overview](https://rnabioco.github.io/molb-7950/course-info/final-projects.html)\n-   [DNA block resources](https://rnabioco.github.io/molb-7950/resources/block-dna-resources.html)\n:::\n\n# Gene regulation by chromatin\n\n## Chromatin organization regulates genome compaction and gene expression\n\n::: {layout-ncol=\"3\" layout-valign=\"center\"}\n![Genome organization](../img/block-dna/ctcf.jpg)\n\n![Cell signaling](../img/block-dna/promoter.png)\n\n![Organism development](../img/block-dna/org-dev.jpg)\n:::\n\n## DNA accessibility drives all biochemical transactions on the genome\n\n::: columns\n::: {.column width=\"50%\"}\n-   Transcription Initiation\n-   Transcription Elongation\n-   DNA Repair\n-   Initiation of DNA Replication\n-   Recombination\n-   Viral Integration\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/domino.gif)\n:::\n:::\n\n## Mapping & measurement are first steps toward understanding. {.smaller}\n\n::: columns\n::: {.column width=\"60%\"}\nBefore genome-wide DNA accessibility measurements, we knew about chromatin transactions at only a handful of loci.\n\nThis was a classic \"keys under the lamppost\" situation, leading to general models of chromatin-based gene regulation.\n:::\n\n::: {.column width=\"40%\"}\n![](../img/block-dna/street-lamp.jpg){width=\"100%\"}\n:::\n:::\n\n::: aside\nPhoto by [Justus Menke](https://unsplash.com/@justusmenke?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/photos/PvQtCNm4teI?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)\n:::\n\n## Using micrococcal nuclease (MNase) to map chromatin {.smaller}\n\n::: columns\n::: {.column .nonincremental width=\"50%\"}\n-   Micrococcal nuclease is an endo/exonuclease from *Staphylococcus aureus*\n-   Efficient, **multiple turnover** enzyme that digests accessible DNA (& RNA)\n-   Dependent on calcium ions\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/mnase-overview.png){fig-align=\"center\"}\n:::\n:::\n\n## Using ATAC to map chromatin {.smaller}\n\n::: columns\n::: {.column .nonincremental width=\"50%\"}\n-   Tn5 transposase catalyzes \"cut-and-paste\" insertion of DNA into a target\n-   In ATAC (\"Assay for Transposase-Accessible Chromatin\"), the transposase enzymes are loaded with DNA sequencing adaptors (blue and red in the image), so the products of transposition are ready to PCR.\n-   **Single turnover enzyme** that acts on accessible DNA.\n-   Requires about \\~60 bp of accessible for transposition.\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/atac-explain.png){fig-align=\"center\"}\n:::\n:::\n\n## **Chromatin mapping experimental summary** {.smaller}\n\n|                           |                     DNase-seq                     |                                             ATAC-seq                                              |             MNase-seq              |\n|---------------------------|:-------------------------------------------------:|:-------------------------------------------------------------------------------------------------:|:----------------------------------:|\n| **Genome representation** |                Most active regions                |                                        Most active regions                                        |            Whole genome            |\n| **Ease of experiment**    |                  Very difficult                   |                                            Easy peasy                                             |           One day's work           |\n| **What is profiled?**     | Accessible DNA, \"footprints\" at low cut frequency | Accessible DNA. Not really \"footprints\", single turnover enzyme, so fragments are not informative | Protections of TFs and nucleosomes |\n\n# Experimental details\n\n##\n\n![](../img/block-dna/footprinting-exp-overview.png)\n\n##\n\n![](../img/block-dna/atac-input-comparison.png)\n\n# Data structures and tools used for analysis of chromatin mapping experiments\n\n## Experimental workflow\n\n![](../img/block-dna/acc-workflow.png)\n\n## BED format {.smaller}\n\n::: columns\n::: {.column .nonincremental width=\"50%\"}\n-   Contains information about genomic intervals.\n-   Used to represent genomic features (exons, introns, transcription start sites)\n-   First 3 columns are: `chrom`, `start`, `end`\n-   Next 3 are: `name`, `score`, `strand`. Strand can be `+`, `-`, or `.` (no strand)\n:::\n\n::: {.column width=\"50%\"}\n```\nchr7 127473530 127474697 Pos3 0  +\nchr7 127474697 127475864 Pos4 0  +\nchr7 127475864 127477031 Neg1 0  -\nchr7 127477031 127478198 Neg2 0  -\n```\n:::\n:::\n\n## WIG / bedGraph {.smaller}\n\n::: columns\n::: {.column .nonincremental width=\"50%\"}\n- WIG and bedGraph store interval *signals*.\n\n    * Genome sequencing coverage\n    * Coverage of reads from MNase / ATAC-seq\n\n- Many studies will provide genome-scale data in these formats\n:::\n\n::: {.column width=\"50%\"}\n```\nchr19 49302000 49302300 -1.0\nchr19 49302300 49302600 -0.75\nchr19 49302600 49302900 -0.50\nchr19 49302900 49303200 -0.25\n```\n:::\n:::\n\n::: {.callout-note}\nbigWig is a binary form of WIG, used to store large amounts of signal in a compressed, indexed format.\n:::\n\n## Interval analysis {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\nThe primary tool in the genome interval analysis is [BEDtools](https://bedtools.readthedocs.io/en/latest/) -- it's the Swiss-army knife of internal analysis.\n\nWe will use an R package called [valr](https://rnabioco.github.io/valr/) that provides the same tools, but you don't need to leave RStudio. valr provides the same tools for reading and manipulating genome intervals.\n\n`bed_intersect()` is a fundamental operation. It identifies intervals from two tibbles that intersect and reports their overlaps.\n\nLet's take a look at that it does.\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/intersect-glyph.png)\n:::\n:::\n\n## `bed_intersect()` example {.smaller}\n\nFirst, we'll define some example intervals in `x` and `y`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(valr)\nlibrary(dplyr)\n\nx <- tribble(\n  ~chrom, ~start, ~end,\n  \"chr1\", 25, 50,\n  \"chr1\", 100, 125\n)\n\ny <- tribble(\n  ~chrom, ~start, ~end,\n  \"chr1\", 30,     75\n)\n```\n:::\n\n\n---\n\nVisual representation of the intersecting intervals.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides-16_files/figure-revealjs/bed_intersect-glyph-1.png){width=960}\n:::\n:::\n\n\n---\n\nTibble of the intersecting intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbed_intersect(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 6\n  chrom start.x end.x start.y end.y .overlap\n  <chr>   <dbl> <dbl>   <dbl> <dbl>    <int>\n1 chr1       25    50      30    75       20\n```\n\n\n:::\n:::\n\n\n::: {.callout-note}\nNote the addition of `.x` and `.y` suffixes to disamguate the input sources.\n:::\n\n## `read_bed()` example\n\nRse `read_bed()` to load genome annotations and signals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsnps <- read_bed(\n  valr_example(\"hg19.snps147.chr22.bed.gz\")\n)\n\ngenes <- read_bed(\n  valr_example(\"genes.hg19.chr22.bed.gz\")\n)\n```\n:::\n\n\n::: {.callout-note}\nYou'll also use `read_bedgraph()` and `read_bigwig()` on your problem set.\n:::\n\n## What is in `snps` and `genes`? {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsnps\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10,000 × 6\n   chrom    start      end name        score strand\n   <chr>    <int>    <int> <chr>       <chr> <chr> \n 1 chr22 16053247 16053248 rs587721086 0     +     \n 2 chr22 16053443 16053444 rs80167676  0     +     \n 3 chr22 16055964 16055965 rs587706951 0     +     \n 4 chr22 16069373 16069374 rs2154787   0     +     \n 5 chr22 16069782 16069783 rs1963212   0     +     \n 6 chr22 16100513 16100514 rs8140563   0     +     \n 7 chr22 16114622 16114623 rs558374111 0     +     \n 8 chr22 16115181 16115182 rs567521927 0     +     \n 9 chr22 16115377 16115378 rs538733846 0     +     \n10 chr22 16121639 16121640 rs544560983 0     +     \n# ℹ 9,990 more rows\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 732 × 6\n   chrom    start      end name      score strand\n   <chr>    <int>    <int> <chr>     <chr> <chr> \n 1 chr22 16150259 16193004 AK022914  8     -     \n 2 chr22 16162065 16172265 LINC00516 3     +     \n 3 chr22 16179617 16181004 BC017398  1     -     \n 4 chr22 16239287 16239327 DQ590589  1     +     \n 5 chr22 16240245 16240277 DQ573684  1     -     \n 6 chr22 16240300 16240340 DQ595048  1     -     \n 7 chr22 16241085 16241125 DQ590589  1     +     \n 8 chr22 16242753 16242785 DQ573684  1     -     \n 9 chr22 16243382 16243414 DQ573684  1     -     \n10 chr22 16243447 16243487 DQ587539  1     -     \n# ℹ 722 more rows\n```\n\n\n:::\n:::\n\n\n## Interval manipulation {.smaller}\n\nLet's find and characterize intergenic SNPs. We'll use the tools [`bed_substract()`](https://rnabioco.github.io/valr/reference/bed_subtract.html) and [`bed_closest()`](https://rnabioco.github.io/valr/reference/bed_closest.html). Take a look and their examples in the valr documentation to see what they do.\n\nHere, we'll ask the question: **\"Which SNPs are intergenic, and how far are they from the nearest gene?\"**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# find snps in intergenic regions\nintergenic <- bed_subtract(snps, genes)\n\n# find distance from intergenic snps to nearest gene\nnearby <- bed_closest(intergenic, genes)\n```\n:::\n\n\nTake a look at the `intergenic` and `nearby` objects in the console.\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintergenic\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,786 × 6\n   chrom    start      end name        score strand\n   <chr>    <int>    <int> <chr>       <chr> <chr> \n 1 chr22 16053247 16053248 rs587721086 0     +     \n 2 chr22 16053443 16053444 rs80167676  0     +     \n 3 chr22 16055964 16055965 rs587706951 0     +     \n 4 chr22 16069373 16069374 rs2154787   0     +     \n 5 chr22 16069782 16069783 rs1963212   0     +     \n 6 chr22 16100513 16100514 rs8140563   0     +     \n 7 chr22 16114622 16114623 rs558374111 0     +     \n 8 chr22 16115181 16115182 rs567521927 0     +     \n 9 chr22 16115377 16115378 rs538733846 0     +     \n10 chr22 16121639 16121640 rs544560983 0     +     \n# ℹ 4,776 more rows\n```\n\n\n:::\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnearby\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,798 × 13\n   chrom  start.x    end.x name.x   score.x strand.x start.y\n   <chr>    <int>    <int> <chr>    <chr>   <chr>      <int>\n 1 chr22 16053247 16053248 rs58772… 0       +         1.62e7\n 2 chr22 16053443 16053444 rs80167… 0       +         1.62e7\n 3 chr22 16055964 16055965 rs58770… 0       +         1.62e7\n 4 chr22 16069373 16069374 rs21547… 0       +         1.62e7\n 5 chr22 16069782 16069783 rs19632… 0       +         1.62e7\n 6 chr22 16100513 16100514 rs81405… 0       +         1.62e7\n 7 chr22 16114622 16114623 rs55837… 0       +         1.62e7\n 8 chr22 16115181 16115182 rs56752… 0       +         1.62e7\n 9 chr22 16115377 16115378 rs53873… 0       +         1.62e7\n10 chr22 16121639 16121640 rs54456… 0       +         1.62e7\n# ℹ 4,788 more rows\n# ℹ 6 more variables: end.y <int>, name.y <chr>,\n#   score.y <chr>, strand.y <chr>, .overlap <int>,\n#   .dist <int>\n```\n\n\n:::\n:::\n\n\n## Interval manipulation {.smaller}\n\nNow that you have overlaps and distances between SNPs and genes, you can go back to dplyr tools to generate reports.\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nnearby |>\n  select(\n    starts_with(\"name\"),\n    .overlap,\n    .dist\n  ) |>\n  filter(abs(.dist) < 5000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,047 × 4\n   name.x      name.y   .overlap .dist\n   <chr>       <chr>       <int> <int>\n 1 rs530458610 P704P           0  2579\n 2 rs2261631   P704P           0  -268\n 3 rs570770556 POTEH           0  -913\n 4 rs538163832 POTEH           0  -953\n 5 rs190224195 POTEH           0 -1399\n 6 rs2379966   DQ571479        0  4750\n 7 rs142687051 DQ571479        0  3558\n 8 rs528403095 DQ571479        0  3309\n 9 rs555126291 DQ571479        0  2745\n10 rs5747567   DQ571479        0 -1778\n# ℹ 1,037 more rows\n```\n\n\n:::\n:::\n\n\n## `bed_map()` example\n\n::: columns\n::: {.column width=\"50%\"}\n`bed_map()` does two things in order:\n\n::: nonincremental\n1.  It identifies intersecting intervals between `x` and `y`\n2.  Calculates summary statistics based on the intersection\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n![](../img/block-dna/map-glyph.png)\n:::\n:::\n\nA typical use is to count up signals (e.g., coverage from an MNase-seq experiment) over specific regions (e.g., promoter regions).\n\n## `bed_map()` example {.smaller}\n\nLet's setup some example data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- tribble(\n  ~chrom, ~start, ~end,\n  \"chr1\", 100,    250,\n  \"chr1\", 250,    500\n)\n\ny <- tribble(\n  ~chrom, ~start, ~end, ~value,\n  \"chr1\", 100,    250,  10,\n  \"chr1\", 150,    250,  20,\n  \"chr1\", 250,    500,  500\n)\n```\n:::\n\n\n## `bed_map()` example continued {.smaller}\n\nFirst examine the intersecting intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbed_intersect(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 7\n  chrom start.x end.x start.y end.y value.y .overlap\n  <chr>   <dbl> <dbl>   <dbl> <dbl>   <dbl>    <int>\n1 chr1      100   250     100   250      10      150\n2 chr1      100   250     150   250      20      100\n3 chr1      100   250     250   500     500        0\n4 chr1      250   500     100   250      10        0\n5 chr1      250   500     150   250      20        0\n6 chr1      250   500     250   500     500      250\n```\n\n\n:::\n:::\n\n\n---\n\nVisual representation of `bed_map()`\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides-16_files/figure-revealjs/bed-map-glyph-1.png){width=960}\n:::\n:::\n\n\n---\n\nComputing multiple summaries with `bed_map()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbed_map(\n  x, y,\n  .sum = sum(value),\n  .count = length(value)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  chrom start   end  .sum .count\n  <chr> <dbl> <dbl> <dbl>  <int>\n1 chr1    100   250    30      2\n2 chr1    250   500   500      1\n```\n\n\n:::\n:::\n\n",
    "supporting": [
      "slides-16_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}