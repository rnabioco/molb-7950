{
  "hash": "5f0340daf8e46ad0b7fa56a9ad60404b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Factor-centric chromatin analysis\"\nauthor: \"Jay Hesselberth\"\n---\n\n\n\n## Where do transcription factors bind in the genome?\n\nToday we'll look at where two yeast transcription factors bind in the genome using CUT&RUN.\n\n## Where do transcription factors bind in the genome?\n\nTechniques like CUT&RUN require an affinity reagent (e.g., an antibody) that uniquely recognizes a transcription factor in the cell.\n\nThis antibody is added to permeabilized cells, and the antibody associates with the epitope. A separate reagent, a fusion of Protein A (which binds IgG) and micrococcal nuclease (MNase) then associates with the antibody. Addition of calcium activates MNase, and nearby DNA is digested. These DNA fragments are then isolated and sequenced to identify sites of TF association in the genome.\n\n## Where do transcription factors bind in the genome?\n\n![Fig 1a, Skene et al.](../img/block-dna/skene-fig-1a.png)\n\n## Data download and pre-processing\n\nCUT&RUN data were downloaded from the [NCBI GEO page](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE84474) for Skene et al.\n\nI selected the 16 second time point for *S. cerevisiae* Abf1 and Reb1 (note the paper combined data from the 1-32 second time points).\n\nBED files containing mapped DNA fragments were separated by size and converted to bigWig with:\n\n``` bash\n#| echo: true\n# separate fragments by size\nawk '($3 - $2 <= 120)' Abf1.bed > CutRun_Abf1_lt120.bed\nawk '($3 - $2 => 150)' Abf1.bed > CutRun_Abf1_gt150.bed\n\n# for each file with the different sizes\nbedtools genomecov -i Abf1.bed -g sacCer3.chrom.sizes -bg > Abf1.bg\nbedGraphToBigWig Abf1.bg sacCer3.chrom.sizes Abf1.bw\n```\n\nThe bigWig files are available here in the `data/` directory.\n\n## Questions\n\n1.  How do you ensure your antibody recognizes what you think it recognizes? What are important controls for ensuring it recognizes a specific epitope?\n\n2.  What are some good controls for CUT&RUN experiments?\n\n# CUT&RUN analysis\n\n## Set up libraries\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\nlibrary(valr)\n\n# genome viz\nlibrary(TxDb.Scerevisiae.UCSC.sacCer3.sgdGene)\nlibrary(Gviz)\nlibrary(rtracklayer)\n\n# motif discovery and viz\nlibrary(BSgenome.Scerevisiae.UCSC.sacCer3)\nlibrary(rGADEM)\nlibrary(seqLogo)\n```\n:::\n\n\n\n## Examine genome coverage\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrack_start <- 90000\ntrack_end <- 150000\n\n# genes track\nsgd_genes_trk <-\n  GeneRegionTrack(\n    TxDb.Scerevisiae.UCSC.sacCer3.sgdGene,\n    chromosome = \"chrII\",\n    start = track_start,\n    end = track_end,\n    background.title = \"white\",\n    col.title = \"black\",\n    fontsize = 16\n  )\n```\n:::\n\n\n\n\n## Examine genome coverage\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# signal tracks\n\ntrack_info <-\n  tibble(\n    file_name = c(\n      \"CutRun_Reb1_lt120.bw\",\n      \"CutRun_Abf1_lt120.bw\",\n      \"CutRun_Reb1_gt150.bw\",\n      \"CutRun_Abf1_gt150.bw\"\n    ),\n    sample_type = c(\n      \"Reb1_Short\", \"Abf1_Short\",\n      \"Reb1_Long\", \"Abf1_Long\"\n    )\n  ) |>\n  mutate(\n    file_path = here(\"data/block-dna\", file_name),\n    big_wig = purrr::map(\n      file_path, ~ import.bw(.x, as = \"GRanges\")\n    ),\n    data_track = purrr::map2(\n      big_wig, sample_type,\n      ~ DataTrack(\n        .x,\n        name = .y,\n        background.title = \"white\",\n        col.title = \"black\",\n        col.axis = \"black\",\n        fontsize = 16\n      )\n    )\n  ) |>\n  dplyr::select(sample_type, big_wig, data_track)\n```\n:::\n\n\n\n## Examine genome coverage\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# x-axis track\nx_axis_trk <- GenomeAxisTrack(\n  col = \"black\",\n  col.axis = \"black\",\n  fontsize = 16\n)\n```\n:::\n\n\n\n## Examine genome coverage\nNow that we have tracks loaded, we can make a plot.\n\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\nplotTracks(\n  c(\n    sgd_genes_trk,\n    track_info$data_track,\n    x_axis_trk\n  ),\n  from = track_start,\n  to = track_end,\n  chromosome = \"chrII\",\n  transcriptAnnotation = \"gene\",\n  shape = \"arrow\",\n  type = \"histogram\"\n)\n```\n\n::: {.cell-output-display}\n![](slides-20_files/figure-revealjs/plot-tracks-1.png){width=960}\n:::\n:::\n\n\n\n## Questions\n\n1.  What features stand out in the above tracks? What is different between Reb1 and Abf1? Between the short and long fragments?\n\n2.  Where are the major signals with respect to genes?\n\n## Peak calling\n\nA conceptually simple approach to identification of regions containing \"peaks\" where a transcription factor was bound is available in the MACS software ([paper](), [github]()). There's also a nice [blog post](https://hbctraining.github.io/Intro-to-ChIPseq/lessons/05_peak_calling_macs.html) covering the main ideas.\n\n## Theory\n\nThe Poisson distribution is a discrete probability distribution of the form:\n\n$$ P_\\lambda (X=k) = \\frac{ \\lambda^k }{ k! * e^{-\\lambda} } $$\n\nwhere $\\lambda$ captures both the mean and variance of the distribution.\n\nThe R functions `dpois()`, `ppois()`, and `rpois()` provide access to the density, distribution, and random generation for the Poisson distribution. See `?dpois` for details.\n\n## Theory\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](slides-20_files/figure-revealjs/plot-poisson-1.png){width=960}\n:::\n:::\n\n\n\n## Practice\n\nHere, we model read coverage using the Poisson distribution. Given some genome size $G$ and and a number of reads collected $N$, we can approximate $\\lambda$ from $N/G$.\n\nMACS uses this value (the \"genomewide\" lambda) and also calculates several \"local\" lambda values to account for variation among genomic regions. We'll just use the genomewide lambda, which provides a conservative threshold for peak calling.\n\nUsing the genomewide lambda, we can use the Poisson distribution to address the question: **How surprised should I be to see** $k$ reads at position X?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nabf1_tbl <- read_bigwig(here(\"data/block-dna/CutRun_Abf1_lt120.bw\"))\n\n# number of reads in the original Abf1 BED file\ntotal_reads <- 16e6\n\ngenome <- read_genome(here(\"data/block-dna/sacCer3.chrom.sizes\"))\ngenome_size <- sum(genome$size)\n\ngenome_lambda <- total_reads / genome_size\n\npeak_calls <-\n  abf1_tbl |>\n  # define single-base sites\n  mutate(\n    midpoint = start + round((end - start) / 2),\n    start = midpoint,\n    end = start + 1,\n    # use the poisson to calculate a p-value with the genome-wide lambda\n    pval = dpois(score, genome_lambda),\n    # convert p-values to FDR\n    fdr = p.adjust(pval, method = \"fdr\")\n  )\n```\n:::\n\n\n\n## P-values\n\nLet's take a look at a plot of the p-value across a chromosome. What do you notice about this plot, when compared to the coverage of the CUT&RUN coverage above?\n\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\nggplot(\n  filter(peak_calls, chrom == \"chrII\"),\n  aes(start, -log10(pval))\n) +\n  geom_line() +\n  xlim(track_start, track_end) +\n  theme_cowplot()\n```\n\n::: {.cell-output-display}\n![](slides-20_files/figure-revealjs/plot-p-vals-1.png){width=960}\n:::\n:::\n\n\n\n## Peaks\n\nHow many peaks are called in this region?\n\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\n# most stringent cut-off\npeak_calls_sig <-\n  filter(\n    peak_calls,\n    fdr == 0\n  ) |>\n  # collapse neighboring, significant sites\n  bed_merge(max_dist = 20)\n\nfilter(\n  peak_calls_sig,\n  chrom == \"chrII\" &\n    start >= track_start &\n    end <= track_end\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 3\n  chrom  start    end\n  <chr>  <int>  <int>\n1 chrII 100248 100289\n2 chrII 101292 101393\n3 chrII 124916 124949\n4 chrII 136181 136264\n5 chrII 141070 141121\n```\n\n\n:::\n:::\n\n\n\n## Visualize\n\nLet's visualize these peaks in the context of genomic CUT&RUN signal. We need to define an `AnnotationTrack` with the peak intervals, which we can plot against the CUT&RUN coverage we defined above.\n\nLet us load the data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# need a GRanges object to convert to an AnnotationTrack\npeak_calls_gr <-\n  GRanges(\n    seqnames = peak_calls_sig$chrom,\n    ranges = IRanges(peak_calls_sig$start, peak_calls_sig$end)\n  )\n\npeak_calls_trk <-\n  AnnotationTrack(\n    peak_calls_gr,\n    name = \"Peak calls\",\n    fill = \"red\",\n    background.title = \"white\",\n    col.title = \"red\",\n    fontsize = 16,\n    rotation.title = 0\n  )\n\nabf1_short_trk <-\n  filter(\n    track_info,\n    sample_type == \"Abf1_Short\"\n  ) |>\n  pull(data_track)\n```\n:::\n\n\n\n## Visualize\n\nAnd plot:\n\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\nplotTracks(\n  c(\n    sgd_genes_trk,\n    abf1_short_trk,\n    peak_calls_trk,\n    x_axis_trk\n  ),\n  from = track_start,\n  to = track_end,\n  chromosome = \"chrII\",\n  transcriptAnnotation = \"gene\",\n  shape = \"arrow\",\n  type = \"histogram\"\n)\n```\n\n::: {.cell-output-display}\n![](slides-20_files/figure-revealjs/plot-peaks-2-1.png){width=960}\n:::\n:::\n\n\n\n## Questions\n\n1.  How many peaks were called throughout the genome? How wide are the called peaks, on average?\n\n2.  How else might we define a significance threshold for identifying peaks?\n\n3.  What might the relative heights of the peaks indicate? What types of technical or biological variables might influence peak heights?\n",
    "supporting": [
      "slides-20_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}