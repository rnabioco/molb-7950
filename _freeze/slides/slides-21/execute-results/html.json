{
  "hash": "8c9209a91f0afd4bbcf4b9ac87867d50",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Factor-centric chromatin analysis\"\nauthor: \"{{< var instructor.block.dna >}}\"\n---\n\n## Where do transcription factors bind in the genome?\n\nToday we'll look at where two yeast transcription factors bind in the genome using CUT&RUN.\n\n## Where do transcription factors bind in the genome?\n\nTechniques like CUT&RUN require an affinity reagent (e.g., an antibody) that uniquely recognizes a transcription factor in the cell.\n\nThis antibody is added to permeabilized cells, and the antibody associates with the epitope. A separate reagent, a fusion of Protein A (which binds IgG) and micrococcal nuclease (MNase) then associates with the antibody. Addition of calcium activates MNase, and nearby DNA is digested. These DNA fragments are then isolated and sequenced to identify sites of TF association in the genome.\n\n## Where do transcription factors bind in the genome?\n\n![Fig 1a, Skene et al.](../img/block-dna/skene-fig-1a.png)\n\n## Data download and pre-processing\n\nCUT&RUN data were downloaded from the [NCBI GEO page](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE84474) for Skene et al.\n\nI selected the 16 second time point for *S. cerevisiae* Abf1 and Reb1 (note the paper combined data from the 1-32 second time points).\n\nBED files containing mapped DNA fragments were separated by size and converted to bigWig with:\n\n``` bash\n# separate fragments by size\nawk '($3 - $2 <= 120)' Abf1.bed > CutRun_Abf1_lt120.bed\nawk '($3 - $2 => 150)' Abf1.bed > CutRun_Abf1_gt150.bed\n\n# for each file with the different sizes\nbedtools genomecov -i Abf1.bed -g sacCer3.chrom.sizes -bg > Abf1.bg\nbedGraphToBigWig Abf1.bg sacCer3.chrom.sizes Abf1.bw\n```\n\nThe bigWig files are available here in the `data/` directory.\n\n# CUT&RUN analysis {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(here)\nlibrary(valr)\n\n# genome viz\nlibrary(TxDb.Scerevisiae.UCSC.sacCer3.sgdGene)\nlibrary(Gviz)\n\n# motif discovery and viz\nlibrary(BSgenome.Scerevisiae.UCSC.sacCer3)\nlibrary(memes)\nlibrary(ggseqlogo)\n```\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrack_start <- 90000\ntrack_end <- 150000\n\n# genes track\nsgd_genes_trk <-\n  GeneRegionTrack(\n    TxDb.Scerevisiae.UCSC.sacCer3.sgdGene,\n    chromosome = \"chrII\",\n    start = track_start,\n    end = track_end,\n    background.title = \"white\",\n    col.title = \"black\",\n    fontsize = 16\n  )\n```\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# signal tracks\ntrack_info <-\n  tibble(\n    file_name = c(\n      \"CutRun_Reb1_lt120.bw\",\n      \"CutRun_Abf1_lt120.bw\",\n      \"CutRun_Reb1_gt150.bw\",\n      \"CutRun_Abf1_gt150.bw\"\n    ),\n    sample_type = c(\n      \"Reb1_Short\",\n      \"Abf1_Short\",\n      \"Reb1_Long\",\n      \"Abf1_Long\"\n    )\n  ) |>\n  mutate(\n    file_path = here(\"data/block-dna\", file_name),\n    big_wig = purrr::map(\n      file_path,\n      \\(x) read_bigwig(x, as = \"GRanges\")\n    ),\n    data_track = purrr::map2(\n      big_wig,\n      sample_type,\n      \\(x, y) {\n        DataTrack(\n          x,\n          name = y,\n          background.title = \"white\",\n          col.title = \"black\",\n          col.axis = \"black\",\n          fontsize = 16\n        )\n      }\n    )\n  ) |>\n  dplyr::select(sample_type, big_wig, data_track)\n\n# x-axis track\nx_axis_trk <- GenomeAxisTrack(\n  col = \"black\",\n  col.axis = \"black\",\n  fontsize = 16\n)\n```\n:::\n\n\n---\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\nplotTracks(\n  c(\n    sgd_genes_trk,\n    track_info$data_track,\n    x_axis_trk\n  ),\n  from = track_start,\n  to = track_end,\n  chromosome = \"chrII\",\n  transcriptAnnotation = \"gene\",\n  shape = \"arrow\",\n  type = \"histogram\"\n)\n```\n\n::: {.cell-output-display}\n![](slides-21_files/figure-revealjs/plot-tracks-1.png){fig-alt='Genome browser tracks for Abf1 and Reb1 CUT&RUN data.' width=960}\n:::\n:::\n\n\n## Peak calling {.smaller}\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\nabf1_tbl <- read_bigwig(here(\"data/block-dna/CutRun_Abf1_lt120.bw\"))\ntotal_reads <- 16e6\n\ngenome <- read_genome(here(\"data/block-dna/sacCer3.chrom.sizes\"))\ngenome_size <- sum(genome$size)\n\ngenome_lambda <- total_reads / genome_size\npeak_calls <-\n  abf1_tbl |>\n  # define single-base sites\n  mutate(\n    midpoint = start + round((end - start) / 2),\n    start = midpoint,\n    end = start + 1,\n    # use the poisson to calculate a p-value with the genome-wide lambda\n    pval = dpois(value, genome_lambda),\n    # convert p-values to FDR\n    fdr = p.adjust(pval, method = \"fdr\")\n  )\n```\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeak_calls_sig <-\n  filter(\n    peak_calls,\n    fdr == 0\n  ) |>\n  # collapse neighboring, significant sites\n  bed_merge(max_dist = 20)\n\nfilter(\n  peak_calls_sig,\n  chrom == \"chrII\" &\n    start >= track_start &\n    end <= track_end\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 Ã— 3\n  chrom  start    end\n  <chr>  <int>  <int>\n1 chrII 100248 100289\n2 chrII 101292 101393\n3 chrII 124916 124949\n4 chrII 136181 136264\n5 chrII 141070 141121\n```\n\n\n:::\n:::\n\n\n## How do proteins recognize specific locations in the genome to bind?\n\n## Motif discovery\n\n## Theory\n\nThere are two major approaches to defining sequence motifs enriched in a sample: enumerative and probabilistic approaches.\n\n## Theory\n\nHere we'll apply a probabilistic approach (MEME) to discover motifs in a collection of DNA sequences. During the RNA block, you'll learn about k-mer analysis, which is a form of enumerative approach.\n\nIn each case, the goal is to define a set of sequence motifs that are encriched in a set of provided sequences (i.e., peaks from CUT&RUN data) relative to a genomic background.\n\n## Theory\n\nMotifs are expressed in a [Position Weight Matrix](https://en.wikipedia.org/wiki/Position_weight_matrix), which captures the propensities for a position to be a particular nucleotide in a sequence motif.\n\nThese PWMs can be represented as sequence logos, visually represent the amount of information provided by the motif, typically using \"information content\", expressed in bits.\n\n## Theory\n\n![LexA sequence motif](../img/block-dna/lexa-motif.png)\n\n## Practice\n\nWe'll use the [memes](https://bioconductor.org/packages/release/bioc/html/memes.html) package from Bioconductor to derive sequence motifs from the peaks we called above. This is a straightforward process:\n\n1.  Collect the DNA sequences within the peak windows using the BSgenome for *S. cerevisiae*\n2.  Provide those sequences and the genomic background to `runDreme()`, which runs uses an Expectation-Maximization (EM) approach to identify and refine motifs.\n3.  Examine the discovered motifs, and plot as a logo using `ggseqlogo`.\n\n---\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\npeak_calls_gr <-\n  GRanges(\n    seqnames = peak_calls_sig$chrom,\n    ranges = IRanges(peak_calls_sig$start, peak_calls_sig$end)\n  )\n\npeak_seqs <- BSgenome::getSeq(\n  # provided by BSgenome.Scerevisiae.UCSC.sacCer3\n  Scerevisiae,\n  peak_calls_gr\n)\n\nmotif_results <- runStreme(\n  input = peak_seqs,\n  control = \"shuffle\", # use shuffled sequences as control\n  minw = 6, # minimum motif width\n  maxw = 12, # maximum motif width\n  nmotifs = 5, # number of motifs to find\n  seed = 42\n)\n\n# look at the consensus motifs\nmotif_results\n```\n:::\n\n\nNow let's look at the sequence logo for the top hit.\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\nmotif_1 <- motif_results[[1]]\npwm <- motif_1[[1]]@motif\n\nggplot() +\n  geom_logo(pwm) +\n  theme_logo()\n```\n:::\n\n\n## Questions\n\n1.  Does this motif make sense, based on what you know about the requirements and specificity of DNA binding by transcription factors?\n\n2.  How might you confirm that a specific sequence (that conforms to a motif) is bound directly by a transcription factor?\n",
    "supporting": [
      "slides-21_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}