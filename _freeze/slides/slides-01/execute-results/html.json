{
  "hash": "877f6b47950d96de51778fac12ddec76",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R Bootcamp - Day 1\"\nsubtitle: \"R & RStudio overview\"\nauthor: \"{{< var instructor.block.bootcamp-r >}}\"\ndate: last-modified\n---\n\n\n\n# Course overview\n\n## People\n\n* Instructors (Jay Hesselberth, Neel Mukherjee)\n\n* TAs (Nathaly Limon de la Rosa and Ilin Joshi)\n\n### Syllabus\n\n- Read the syllabus.\n\n- Your grades are based on attendance / participation, problem sets, and a final project. Your lowest problem set grade will be dropped.\n\n- If you are sick, let me and Neel know, and stay home. We will record all classes and make them available on Panopto.\n\n## Getting help\n\n* All course details are on the [website](https://rnabioco.github.io/molb-7950/).\n* We use Canvas for problem set submission & grading.\n\n* If you get stuck during class: use the `#class` channel in slack. TAs will come over.\n* If you need help outside of class (in order):\n\n  1. Ask a question on slack.\n  2. Use TA office hourse Tues/Thurs 1-2:30p.\n  3. Schedule time with the instructors.\n\n## Structure of a class\n\n- Prior to each block (and sometimes prior to a class), check and complete material in the \"Prepare\" column on the class schedule.\n\n- On the day of class and before class starts, start the day's \"assignment\" in Posit Cloud. This will contain blank exercises that you'll fill in during class.\n\n- You'll also have access to the slides, but it's probably better for the first few classes to just have the exercises open.\n\n## Problem sets\n\n- You'll have a problem set assigned at the end of each class. Our expectation\nis that you spend a 30-90 minutes on each problem set.\n\n- Problem sets will get progressively more difficult.\n\n- You can work in groups for problem sets (see the Syllabus), but during the Bootcamp\n  you should avoid it.\n\n- If you feel like you're stuck on something silly, reach out through slack or office hours.\n\n- We'll talk about the problem set at the end of each class. You are welcome\n  to use the remaining class time to start and possibly finish the problem set.\n\n## Learning Objectives for the R Bootcamp\n\n- Learn the fundamentals of R programming (*class 1*)\n\n- Become familiar with \"tidyverse\" suite of packages\n\n  - tidyr: \"Tidy\" a messy dataset (*class 2*)\n  - dplyr: Transform data to derive new information (*classes 3 and 6*)\n  - ggplot2: Visualize and communicate results (*classes 4 and 5*)\n  - Putting all of these to use with real data sets (*classes 7 and 8*)\n\n- Practice reproducible analysis using Quarto/Rmarkdown (Rigor & Reproducibility)\n\n## A note on R vs Python, and LLMs\n\nYou will probably hear people say that one of R/Python is better than the other.\n\n**This is false dichotomy**. Both languages are useful for different tasks, and both have their strengths and weaknesses.\n\nWe will spend time later in the course using LLMs to generate code in both R and Python.\n\n# Today's class\n\n## Class outline\n\n* Review R basics\n\n  - R and RStudio (Exercises #1-2)\n  - Functions & Arguments (Exercises #3-4)\n  - Data types and structures (Exercise #5-7)\n  - R Packages (Exercise #8)\n  - Quarto (Exercise #9)\n  - Tidy data\n  - Go over the first problem set\n\n## RStudio - Exercise 1\n\n- We are using RStudio through Posit Cloud for the class.\n- Look at RStudio panels one at a time.\n- Environment, History, Console, Files, Plots, Packages, Help, etc.\n\n. . .\n\nSee menu:\n\n**Help > Cheat Sheets > RStudio IDE Cheat Sheet**\n\n## R as a calculator - Exercise 2\n\n- R can function like an advanced calculator\n\n---\n\nTry simple math.\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# This is a comment line\n# Note the order of operations (PEMDAS).\n2 + 3 * 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 17\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# value of 3-7\n3 - 7\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -4\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# division\n3 / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.5\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# 5 raised to the power of 2\n5^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\n---\n\nAssign a numeric value to an object.\n\n- `<-` and `=` are *assignment* operators.\n- By convention, R programmers use `<-`.\n- `x <- 1` reads \"set the value of `x` to 1\".\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# create `num` object\nnum <- 5^2\nnum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n\n---\n\n`=` and `==` are two different operators.\n\n- a `=` is used for assignment (e.g., `x = 1`)\n\n- a `==` tests for equivalence (e.g. `x == 1` says \"does `x` equal 1?\")\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nx <- 1\nx == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nx == 10\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# does `x` NOT equal 5?\nx != 5\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n## Functions and arguments - Exercise 3\n\n* Functions are fundamental building blocks of R\n* Most functions take one or more arguments and transform an input object in a specific way.\n* Use tab-completion to find functions!\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# use `?log` to see the help page\nlog(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.386294\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlog(4, base = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n## Writing a simple function - Exercise 4\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\naddtwo <- function(x) {\n  num <- x + 2\n  return(num)\n}\n\naddtwo(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n## Data types - Exercise 5\n\n* There are many data types in R.\n* We'll mainly use **numeric**, **character**, and **logical**.\n\n. . .\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nclass(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nclass(\"RNA\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nclass(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# coerce one type to another\nclass(as.character(TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n## Vectors - Exercise 6\n\nVectors are a core R data structure.\n\n- A vector is an ordered collection of elements of the same type (e.g. numeric, character, or logical).\n\n- Later you will see that every column of a `data.frame` / `tibble` is a vector.\n\n- Operations on vectors propagate to all the elements of the vectors.\n\n---\n\nLet's create some vectors.\n\n- The `c` function combines values together (e.g., `c(1,2,3)`)\n\n. . .\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nx <- c(1, 3, 2, 10, 5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  3  2 10  5\n```\n\n\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n---\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\ny <- 1:5\n\ny + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4 5 6 7\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n2 * y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\ny^2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  9 16 25\n```\n\n\n:::\n:::\n\n\n---\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# `y` has not changed!\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 4 5\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# this will update the value of `y`\ny <- y * 2\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10\n```\n\n\n:::\n:::\n\n\n## Data frames\n\n- A `data.frame` is a rectangle, where each column is a vector, and each row is a slice across vectors.\n\n- `data.frame` columns are vectors, and can have different types (numeric, character, factor, etc.).\n\n- A `data.frame` is constructed with `data.frame()`.\n\n---\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nclass(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris\n\n# access a data.frame columen with the `$` operator\niris$Species\n```\n:::\n\n\n<br>\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ndata.frame(x = c(1, 2, 3), y = c(2, 4, 6))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 2\n2 2 4\n3 3 6\n```\n\n\n:::\n:::\n\n\n## Tibbles\n\n* A *tibble* is a modern reimagining of the data.frame, keeping what time has proven to be effective, and throwing out what is not.\n\n* Tibbles are data.frames that are lazy and surly: they do less (i.e. they don't change variable names or types, and don't do partial matching) and complain more (e.g. when a variable does not exist).\n\n## Data frames & tibbles - Exercise 7\n\nCreate a data.frame and tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchrom <- c(\"chr1\", \"chr1\", \"chr2\")\nstart <- c(200, 4000, 100)\nend <- c(250, 410, 200)\nstrand <- c(\"-\", \"-\", \"+\")\n\ndf <- data.frame(chrom, start, end, strand)\n\ntbl <- tibble(chrom, start, end, strand)\n```\n:::\n\n\nNow echo the contents of `df` and `tbl` to the console and inspect\n\n---\n\nSome useuful functions for inspecting data.frames and tibbles:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the number of rows and columns\nnrow(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nncol(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# get the dimensions (rows, columns)\ndim(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# get the column names\nnames(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"chrom\"  \"start\"  \"end\"    \"strand\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# glimpse at the data\nglimpse(tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3\nColumns: 4\n$ chrom  <chr> \"chr1\", \"chr1\", \"chr2\"\n$ start  <dbl> 200, 4000, 100\n$ end    <dbl> 250, 410, 200\n$ strand <chr> \"-\", \"-\", \"+\"\n```\n\n\n:::\n:::\n\n\n## R packages - Exercise 8\n\n* An R package is a collection of code, data, documentation, and tests that is easily shareable.\n\n* A package often has a collection of custom functions that enable you to carry out a workflow. eg. DESeq2 for RNA-seq analysis.\n\n* The most popular places to get R packages from are CRAN, Bioconductor, and Github.\n\n* Once a package is installed, one still has to \"load\" them into the environment using a `library(<package>)` call.\n\n---\n\nLet's do the following to explore R packages:\n\n* `library(tidyverse)`\n* Examine the \"Environment\" panel in Rstudio\n* Explore Global Environment\n* Explore the contents of a package\n\n## Tidyverse overview\n\n* Tidyverse is an opinionated collection of R packages designed for data science.\n* All packages share an underlying design philosophy, grammar, and data structures.\n* Comprised of a few dozen packages - we will focus mainly on tidyr, dplyr, and ggplot2\n\n# Tidyverse overview\n\n## Tidyverse workflow\n\n![](../img/tidy-workflow.png)\n\n## What is tidy data?\n\n>   \"Tidy datasets are all alike but every messy dataset is messy in its own way.\"\n>\n>   --- Hadley Wickham\n\n![](../img/tidydata.png)\n\n## Quarto Exercise - Exercise 9\n\n* [Quarto](https://quarto.org) is a fully reproducible authoring framework to create, collaborate, and communicate your work.\n\n* Quarto lets you render Rmarkdown documents (in addition to Jupyter notebooks, etc.)\n\n* Quarto supports a number of output formats including pdfs, word documents, slide shows, html, etc.\n\n---\n\n* A Quarto document is a plain text file with the extension `.qmd` and contains the following basic components:\n\n  - A YAML header surrounded by `---`.\n  - Chunks of R code surrounded by ```.\n  - Plain text structured with [markdown](https://www.markdownguide.org/basic-syntax) formatting like `# heading` and `*italics*`.\n\n---\n\nLet's do the following to explore Quarto documents:\n\n* Create a new Quarto document\n* Render the document to see the output\n\n## Problem sets and submission\n\nYour first problem set is in `ps-01.qmd`\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}