{
  "hash": "3139b2c527ae6b8510c87ff155bac990",
  "result": {
    "markdown": "---\ntitle: \"R Bootcamp - Day 1\"\nsubtitle: \"R & RStudio overview\"\nauthor: \"Jay Hesselberth\"\ndate: last-modified\n---\n\n\n\n\n# Course overview \n\n## People\n\n* Instructors (me, Neel Mukherjee, Kent Riemondy)\n\n* TAs (Kathryn Walters and Brandon Buck)\n\n### Syllabus \n\n- Read the syllabus.\n\n- Your grades are based on attendance / participation, problem sets, and a final project. Your lowest problem set grade will be dropped.\n\n- If you are sick, let me and Neel know, and stay home. We will record all classes and make them available on Panopto.\n\n## Getting help\n\n* All course details are on the [website](https://rnabioco.github.io/molb-7950/).\n* We use Canvas for problem set submission & grading.\n\n* If you get stuck during class: use the `#class` channel in slack. TAs will come over.\n* If you need help outside of class (in order):\n\n  1. Ask a question on slack.\n  2. Use calendly to schedule time with the TAs.\n  3. Use calendly to schedule time with me or Neel.\n  4. E-mail Jay.\n\n## Structure of a class\n\n- Prior to each block (and sometimes prior to a class), check and complete material in the \"Prepare\" column on the class schedule.\n\n- On the day of class and before class starts, start the day's \"assignment\" in Posit Cloud. This will contain blank exercises that you'll fill in during class.\n\n- You'll also have access to the slides, but it's probably better for the first few classes to just have the exercises open.\n    \n## Problem sets\n\n- You'll have a problem set assigned at the end of each class. Our expectation\nis that you spend a 30-90 minutes on each problem set.\n\n- Problem sets will get progressively more difficult.\n\n- You can work in groups for problem sets (see the Syllabus), but during the Bootcamp\n  you should avoid it.\n\n- If you feel like you're stuck on something silly, reach out through slack or office hours.\n\n- We'll talk about the problem set at the end of each class. You are welcome\n  to use the remaining class time to start and possibly finish the problem set.\n\n## Learning Objectives for the R Bootcamp\n\n- Learn the fundamentals of R programming (*class 1*)\n\n- Become familiar with \"tidyverse\" suite of packages\n\n  - tidyr: \"Tidy\" a messy dataset (*class 2*)\n  - dplyr: Transform data to derive new information (*classes 3 and 6*)\n  - ggplot2: Visualize and communicate results (*classes 4 and 5*)\n  - Putting all of these to use with real data sets (*classes 7 and 8*)\n  \n- Practice reproducible analysis using Quarto/Rmarkdown (Rigor & Reproducibility)\n\n## Today's class outline\n\n* Review R basics\n\n  - R vs Rstudio (Exercises #1-2)\n  - Functions & Arguments (Exercises #3-4)\n  - Data types (Exercise #5)\n  - Data structures (Exercises #6-7)\n  - R Packages (Exercise #8)\n  \n* Review Quarto/Rmarkdown (Exercise #9)\n\n## RStudio - Exercise 1\n\n- We are using RStudio through Posit Cloud for the class.\n- Look at RStudio panels one at a time.\n- Environment, History, Console, Files, Plots, Packages, Help, etc.\n\n. . .\n\nSee menu:\n\n**Help > Cheat Sheets > RStudio IDE Cheat Sheet**\n\n## R as a calculator - Exercise 2\n\n- R can function like an advanced calculator\n\n---\n\nTry simple math.\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# This is a comment line\n# Note the order of operations (PEMDAS).\n2 + 3 * 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 17\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# value of 3-7\n3 - 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -4\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# division\n3 / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.5\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# 5 raised to the power of 2\n5^2 \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n:::\n\n\n---\n\nAssign a numeric value to an object.\n\n- `<-` and `=` are *assignment* operators.\n- By convention, R programmers use `<-`.\n- `x <- 1` reads \"set the value of `x` to 1\".\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# create `num` object\nnum <- 5^2 \nnum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 25\n```\n:::\n:::\n\n\n---\n\n`=` and `==` are two different operators.\n\n- a `=` is used for assignment (e.g., `x = 1`)\n\n- a `==` tests for equivalence (e.g. `x == 1` says \"does `x` equal 1?\")\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nx <- 1\nx == 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nx == 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n# `x` NOT equals 5?\nx != 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Functions and arguments - Exercise 3\n\n* Functions are fundamental building blocks of R\n* Most functions take one or more arguments and transform an input object in a specific way. \n* Use tab-completion to find functions!\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\n?log\nlog(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.386294\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nlog(4, base = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\n## Writing a simple function - Exercise 4\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\naddtwo <- function(x) {\n  num <- x + 2\n  return(num)\n}\n\naddtwo(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nf <- function(x, y) {\n  z <- 3 * x + 4 * y\n  return(z)\n}\n\nf(2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 18\n```\n:::\n:::\n\n\n## Data types - Exercise 5\n\n* There are many data types in R. \n* We'll mainly use **numeric**, **character**, and **logical**.\n\n. . .\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nclass(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nclass(\"jay\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nclass(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"logical\"\n```\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# coerce one type to another\nclass(as.character(TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"character\"\n```\n:::\n:::\n\n\n## Vectors - Exercise 6\n\nVectors are a core R data structure. \n\n- A vector is an ordered collection of elements of the same type (e.g. numeric, character, or logical). \n\n- Later you will see that every column of a data.table / tibble is a vector. \n\n- Operations on vectors propagate to all the elements of the vectors.\n\n---\n\nLet's create some vectors.\n\n- The `c` function combines values together (e.g., `c(1,2,3)`)\n\n. . .\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nx <- c(1, 3, 2, 10, 5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  3  2 10  5\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\n---\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\ny <- 1:5\n\ny + 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 4 5 6 7\n```\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n2 * y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\ny^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1  4  9 16 25\n```\n:::\n:::\n\n\n---\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# `y` has not changed!\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n```\n:::\n:::\n\n\n<br>\n\n\n::: {.cell output-location='column-fragment'}\n\n```{.r .cell-code}\n# this will update the value of `y`\ny <- y * 2 \ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n\n\n## Data frames\n\n- A data.frame is a rectangle, where each column is a vector, and each row is a slice across vectors.\n\n- data.frame columns are vectors, and can have different types (numeric, character, factor, etc.). \n\n- A data.frame is constructed with `data.frame()`.\n\n---\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\nclass(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris\n```\n:::\n\n\n<br>\n\n\n::: {.cell output-location='fragment'}\n\n```{.r .cell-code}\ndata.frame(x = c(1,2,3), y = c(2,4,6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x y\n1 1 2\n2 2 4\n3 3 6\n```\n:::\n:::\n\n\n## Tibbles\n\n* A *tibble* is a modern reimagining of the data.frame, keeping what time has proven to be effective, and throwing out what is not. \n\n* Tibbles are data.frames that are lazy and surly: they do less (i.e. they don't change variable names or types, and don't do partial matching) and complain more (e.g. when a variable does not exist). \n\n* This forces you to confront problems earlier, typically leading to cleaner, more expressive code. Tibbles also have an enhanced `print()` method which makes them easier to use with large datasets containing complex objects.\n\n---\n\n* `tibble()` does much less than `data.frame()`: \n\n  - it never changes the type of the inputs \n  - it never changes the names of variables\n  - it never creates `row.names()`\n\n## Data frames & tibbles - Exercise 7\n\nCreate a data.frame and tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchrom <- c(\"chr1\", \"chr1\", \"chr2\")\nstart <- c(200, 4000, 100)\nend <- c(250, 410, 200)\nstrand <- c(\"-\", \"-\", \"+\")\n\ndf <- data.frame(chrom, start, end, strand)\n\ntbl <- tibble(chrom, start, end, strand)\n```\n:::\n\n\n. . .\n\nNow echo the contents of `df` and `tbl` to the console and inspect\n\n## R packages - Exercise 8\n\n* An R package is a collection of code, data, documentation, and tests that is easily shareable.\n\n* A package often has a collection of custom functions that enable you to carry out a workflow. eg. DESeq for RNA-seq analysis.\n\n* The most popular places to get R packages from are CRAN, Bioconductor, and Github. \n\n* Once a package is installed, one still has to \"load\" them into the environment using a `library(<package>)` call. \n\n---\n\nLet's do the following to explore R packages:\n\n* Look at the \"Environment\" panel in Rstudio\n* Explore Global Environment\n* Explore the contents of a package\n\n## Quarto Exercise - Exercise 9\n\n* [Quarto](https://quarto.org) is a fully reproducible authoring framework to create, collaborate, and communicate your work. \n\n* Quarto lets you render Rmarkdown documents (in addition to Jupyter notebooks, etc.)\n\n* Quarto supports a number of output formats including pdfs, word documents, slide shows, html, etc. \n\n---\n\n* A Quarto document is a plain text file with the extension `.qmd` and contains the following basic components: \n\n  - A YAML header surrounded by `---`.\n  - Chunks of R code surrounded by ```.\n  - Plain text structured with [markdown](https://www.markdownguide.org/basic-syntax) formatting like `# heading` and `*italics*`.\n\n---\n\nLet's do the following to explore Quarto documents:\n\n* Create a new Quarto document\n* Render the document to see the output\n\n## Problem sets and submission\n\nYour first problem set is in `problem-sets/class-01.qmd`\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}