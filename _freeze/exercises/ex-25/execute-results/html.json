{
  "hash": "dab274288b8c6acffafb3daad2d1fb04",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Alternative splicing\"\nauthor: \"Matthew Taliaferro\"\neditor:\n  markdown:\n    wrap: 72\n---\n\n\n\n## Overview {.smaller}\n\nIn this lecture, we are going focus on analyzing the regulation of\nalternative splicing using RNAseq approaches.As we learned last week,\n`salmon` quantifies a fastq file of sequencing reads against a fasta\nfile of all transcripts present in the sample. At the end of this\nanalysis, we end up with quantifications for each transcript in our\nfasta file. However, for splicing you may be able to see how this\nstrategy may need to be tweaked. `salmon` gave us transcript-level data,\nbut for looking at splicing, we often want to measure how the inclusion\nof individual **exons** within transcripts differs between conditions.\nThus, transcript-level quantifications are not directly useful here.\n\n> Small aside: Actually, transcript level quantifications could work,\n> because you could ask how the relative abundances of two different\n> transcripts (one that has the exon in question and one that doesn't)\n> vary across conditions. See also `suppa2`.\n\n## Split alignments {.smaller}\n\nWe need exon-level quantifications. So we want to count reads that\neither support the inclusion or exclusion of an exon.\n\nBelow are examples of some RNAseq reads mapped along a transcript. This\ntranscript contains exons (yellow) and introns (gray). Let's say that\nthere are two isoforms of this gene: one where `exon2` is included and\none where it is exlcuded. Reads have been \"aligned\" to this transcript\nto give a graphical representation of where they came from. You can see\nthat the orange, purple, blue, and teal reads all *support* the\ninclusion of `exon2`.\n\n![Kim et al, Nat Methods, 2015](/img/block-rna/junc_read.png)\n\n## Split alignments {.smaller}\n\nAnother way to think about this is that the orange, purple, blue, and\nteal reads came from RNA molecules in which the transcript was included.\n\nWe know this because each of those reads cross a **splice junction**\nthat is either `exon1-exon2` or `exon2-exon3`. These reads tell us,\n**unambiguously**, that `exon2` was included in the RNA molecule that\nthese reads came from.\n\n![Kim et al, Nat Methods, 2015](/img/block-rna/junc_read.png)\n\n> What does the red read tell us? What would a read that unambiguously\n> told us that exon2 was *excluded* look like?\n\n## Strategy in action {.smaller}\n\nExample of reads mapped to the area surrounding an alternative exon (the\nmiddle exon). The height of the red and blue area corresponds to the\nnumber of read coverage. The red and blue lines connecting exons\nrepresent the number of reads that span that junction. So for the blue\ncondition, there are 347 reads (91 + 256) that support the inclusion of\nthis exon, while 81 reads support its exclusion. In the red condition,\nthis exon is less often excluded as 296 reads (65 + 231) support its\ninclusion while 130 support its exclusion. *Think about how often an\nexon was included in a sample as a ratio between the inclusion- and\nexclusion-supporting reads*.\n\n![](/img/block-rna/sashimi.png){width=\"50%\"}\n\n## Workflow {.smaller}\n\nWe will focus on the right side of the flowchart that relies on\n[`STAR`](https://github.com/alexdobin/STAR), a splice-aware read\naligner, and [`rMATS`](https://rnaseq-mats.sourceforge.io/), an\nalternative splicing analysis tool.\n\n![](/img/block-rna/flowchart.png)\n\n## How STAR works {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\nSTAR begins by finding matches (either unique or nonunique) between a\nportion of a read and the reference. This matching region of the query\nis extended along the reference until the two start to disagree. If this\nmatch extends all the way through to the end of the read, then the read\nlies completely within one exon (or intron, or I guess intergenic region\nif you are bad at making RNAseq libraries) and we are done. If the match\nends before the end of the read, the part that has matched so far\ndefines one *seed*.\n:::\n\n::: {.column width=\"50%\"}\n![](/img/block-rna/seed1.png)\n:::\n:::\n\n## How STAR works {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\nSTAR then takes the rest of the query and uses it to find the best match\nto its sequence in the reference, defining another seed.\n:::\n\n::: {.column width=\"50%\"}\n![](/img/block-rna/seed2.png)\n:::\n:::\n\n## How STAR works {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\nIf, during the extension of a match a small region of mismatch or\ndiscontinuity occurs, these can be identified as mutations or indels if\nhigh-quality matches between the query and reference resume later in the\nread.\n:::\n\n::: {.column width=\"50%\"}\n![](/img/block-rna/indel.png){width=\"50%\" height=\"100%\"}\n:::\n:::\n\n## How STAR works {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\nAfter aligning seeds, they can be stitched together. The stitching of\nseeds with high alignment quality (low number of indels, mismatches) is\nprefered over the stitching of seeds with low alignment quality (high\nnumber of indels, mismatches).\n:::\n\n::: {.column width=\"50%\"}\n![](/img/block-rna/stitch.png)\n:::\n:::\n\n## Running STAR {.smaller}\n\nTo align reads, we first need to create an **index** of the genome (see\nSTAR manual\n[here](https://physiology.med.cornell.edu/faculty/skrabanek/lab/angsd/lecture_notes/STARmanual.pdf).\nTo do this, `STAR` will require the sequence of the genome (in fasta\nformat), and an annotation that tells it where exons and introns are. It\nneeds the annotation to be able to see if seeds that it stitches\ntogether make sense with what we know about exon/intron structures that\nexist in the transcriptome. Let's take a look at one of these genome\nannotation files.\n\n## Annotation files {.smaller}\n\nThe most common annotation files are `GTF` and `GFF` files. Here's an\nexample of a `GFF`.\n\n![](/img/block-rna/gff.png)\n\nEach line corresponds to one feature. This is a tab-delimited text file.\nThere are only a few columns that we care about:\n\n-   Column 1: chromosome\n-   Column 2: source\n-   Column 3: feature type\n-   Column 4: feature start\n-   Column 5: feature end\n-   Column 7: strand (you aren't in DNA land anymore...strand matters)\n\n## Annotation files {.smaller}\n\n![](/img/block-rna/gff.png)\n\nColumn 8 contains various information about the feature. Perhaps the\nmost important one tells you about the hierarchy that defines the\nrelationship between features. For example, genes contain *children*\ntranscripts within them, and each transcript contains *children* exons.\nTranscripts will therefore belong to *parent* genes and exons will\nbelong to *parent* transcripts. Biologically, this should make sense to\nyou. These relationships are indicated by the **Parent** attribute\nwithin column 8.\n\n## Make STAR index {.smaller}\n\nOK now we are ready to make our index. There relevant options we will\nneed to pay attention to when doing this are shown below:\n\n-   **--runMode** genomeGenerate (we are making an index, not aligning\n    reads)\n-   **--genomeDir** /path/to/genomeDir (where you want STAR to put this\n    index we are making)\n-   **--genomeFastaFiles** /path/to/genomesequence (genome sequence as\n    fasta, either one file or multiple)\n-   **--sjdbGTFfile** /path/to/annotations.gff (yes it says gtf, but we\n    are going to use a gff format)\n-   **--sjdbOverhang** 100 (100 will usually be a good value here, the\n    recommended value is readLength - 1)\n-   **--sjdbGTFtagExonParentTranscript** Parent (we have to specify this\n    because we are using a gff annotation and this is how gff files\n    denote relationships)\n-   **--genomeSAindexNbases** 11 (don't worry about this one, we are\n    specifying it because we are using an artificially small genome in\n    this example)\n\n## Make STAR index {.smaller}\n\n> STAR --runMode genomeGenerate --genomeDir {path-to}/mySTARindex\n> --genomeFastaFiles {path-to}/genome.fasta --sjdbGTFfile\n> {path-to}/MOLB7950.gff3 --sjdbOverhang 100\n> --sjdbGTFtagExonParentTranscript Parent --genomeSAindexNbases 11\n\n![](/img/block-rna/star_index_out.png)\n\n## STAR: align reads {.smaller}\n\nNow that we have our index we are ready to align our reads. The options\nwe need to pay attention to here are:\n\n-   **--runMode** alignReads (we are aligning this time)\n-   **--genomeDir** /path/to/genomeDir (a path to the index we made in\n    the previous step)\n-   **--readFilesIn** /path/to/forwardreads /path/to/reversereads (paths\n    to our fastqs, separated by a space)\n-   **--readFilesCommand** gunzip -c (our reads our gzipped so we need\n    to tell STAR how to read them)\n-   **--outFileNamePrefix** path/to/outputdir (where to put the results)\n-   **--outSAMtype** BAM SortedByCoordinate (the format of the alignment\n    output, more on this later)\n\nNow we are ready to align our reads.\n\n## STAR: align reads {.smaller}\n\n> STAR --runMode alignReads --genomeDir {path-to}/mySTARindex/\n> --readFilesIn {path-to}/MOLB7950_1.fastq.gz\n> {path-to}/MOLB7950_2.fastq.gz --readFilesCommand gunzip -c\n> --outFileNamePrefix {path-to}/myalignments --outSAMtype BAM\n> SortedByCoordinate\n\n![](/img/block-rna/read_align_status.png)\n\n## Mapping stats produced by STAR {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\nWell so how did it go? Check the log file. We can see that we put in\nalmost 100k read pairs and 96.7k of these could be uniquely assigned to\na single genomic position. 95.6k of these had a splice junction. This is\nexpected for paired end reads against a genome with many introns and\nshort exons.\n\nAs an aside, any read that aligns more times than is allowed by the flag\n**--outFilterMultimapNmax** is not reported in the alignments. As a\ndefault, this value is set to 10. Libraries that are made from low\ncomplexity RNA samples and those that deal with repetitive genomic\nregions can be sensitive to this. Also, if you wanted to, you can use\nthis flag to restrict your alignment file to those that only *uniquely*\naligned by setting this value to 1.\n:::\n\n::: {.column width=\"50%\"}\n![](/img/block-rna/star_out.png)\n:::\n:::\n\n## Investigating alignment files {.smaller}\n\nOur alignment output file is `dummyAligned.sortedByCoord.out.bam`. `BAM`\nfiles are binary files and need to be converted to plain text using\n`samtools view` for us to read it.\n\n> samtools view dummyAligned.sortedByCoord.out.bam \\> dummyAligned.sam\n\n## Alignments {.smaller}\n\nSAM files can be a little confusing, but it's worth taking the time to\nget to know them. The full SAM format specification can be found\n[here](https://samtools.github.io/hts-specs/SAMv1.pdf).\n\nLet's take a look at our SAM file and see what we see. I'm going to pick\n2 lines out.\n\n![](/img/block-rna/sam_example.png)\n\nHere we are looking at 2 lines from this file. These two lines\ncorrespond to two paired reads. I know that because the first field in\nthis file is the read ID as it came off the sequencer. You can see that\nthese two reads have the same ID (it's the thing I grepped for).\n\n## Alignments {.smaller}\n\n![](/img/block-rna/sam_example.png)\n\nThe **second** field is a bitwise flag. It is a sum of integers where\neach integer tells us something about the read. Every possible value of\nthis flag is a unique combination of the informative integers. You can\nsee what each of these integers are and what they mean in the [SAM\nformat specification](https://samtools.github.io/hts-specs/SAMv1.pdf).\nThere is also a handy calculator that you can plug your value into and\nit will tell you what your flag means\n[here](https://www.samformat.info/sam-format-flag). If we put our first\nflag, 163, in there it tell us that this read is:\n\n-   The second read in a mate pair (128)\n-   On the opposite strand of its mate pair (32)\n-   Is mapped and properly paired (2)\n-   Is paired (1)\n\nIf you put the flag value for the second read into the calculator, what\ndo you get?\n\n## Alignments {.smaller}\n\n![](/img/block-rna/sam_example.png)\n\nThe **third** field is obviously the reference name. No big mystery\nthere. This read maps to chromosome 19.\n\nThe **fourth** field is the position on the reference that corresponds\nto the beginning of the query. This read starts to map to chr19\nbeginning at position 3371611. As a aside, positions reported in SAM\nfiles are 1-based, not 0-based.\n\n## Alignments {.smaller}\n\n![](/img/block-rna/sam_example.png)\n\nThe **sixth** field is called the CIGAR string. This is a string of\ncharacters that tells you a little bit about *how* the query aligns to\nthe reference. Again, details can be found in the [SAM format\nspecification](https://samtools.github.io/hts-specs/SAMv1.pdf). The\nCIGAR string for the first read can be interpreted as follows:\n\n-   The first 67 bases in the query align to the reference.\n-   There is then a gap in the reference of 3415 nt.\n-   Then the query starts to match again, and does so for the next 84\n    nt.\n\nThese are paired end 151 nt reads, so it makes sense that 67 + 84 = 151.\n\nIn not so shocking news, the top read's mate (the second read) also has\na gap in the reference of 3415 nt. As you might have guessed, these\nreads are spanning the same intron, which you would expect reads from\nthe same mate pair to do.\n\n## Alignments {.smaller}\n\nThe **ninth** field is the *template length*, abbreviated TLEN. This is\nthe distance, in nt, from the beginning of one read in a pair to the end\nof it's mate.\n\n![](/img/block-rna/tlen.png)\n\nIf you know a little bit about how RNAseq libraries are made, you might\nknow that transcripts are fragmented, usually to lengths of 200-500 nt.\nGiven that this read is stretching over 3 kb along the reference\nsequence, it's a good bet that it is spanning an intron that is present\nin the reference but had been removed in the RNA molecule i.e. it was\nspliced out!\n\n## Workflow {.smaller}\n\nNow that we have aligned with `STAR`, we can calculate exon inclusion\nwith `rMATS`. As is often the case with bioinformatic tools, `rMATS` is\nnot the only tool that you can use to look at alternative splicing, but\nit has been around for a while and has been thoroughly tested.\n\n![](/img/block-rna/flowchart.png)\n\n## PSI ($\\psi$) values {.smaller}\n\nIn many scenarios, splicing is quantified using a metric called PSI\n(Percent Spliced In), often shown as the greek letter $\\psi$, is a\nmetric that asks what fraction of transcripts *contain* the exon or RNA\nsequence in question. Thus, $\\psi$ values range from 0 (which would\nindicate that the exon is never included) to 1 (which would indicate\nthat the exon is always included). $\\psi$ can be estimated by counting\nthe number of reads that unambiguously support the inclusion of the exon\nand the number of reads that unambiguously support exclusion of the\nexon.\n\nFor skipped \"cassette\" exons, these reads are diagrammed below:\n\n![Shen et al, (2014). PNAS](/img/block-rna/sepsi.jpg)\n\n## PSI ($\\psi$) values {.smaller}\n\nIn this diagram, the exon in gray can either be included or skipped to\nproduced two different transcript isoforms. Reads in red (I for\ninclusion) unambiguously argue for the inclusion of the exon while reads\nin green (S for skipping) unambiguously argue for skipping of the exon.\nKeep in mind that the reads drawn over splice junctions indicate the the\nread spans the splice junction.\n\n![Shen et al, (2014). PNAS](/img/block-rna/sepsi.jpg)\n\n> Note: Red reads that do not cross a junction but lie totally within\n> the gray exon are often used in splicing analysis, but do not formally\n> unambiguously show exon inclusion. It is safer to rely **only** on\n> splice-junction spanning reads for splicing quantitation. The downside\n> of this is that you will lose read counts that came from non-junction\n> reads. Fewer read counts means less statistical power.\n\n## Types of alternative splicing {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n![Shen et al, (2014). PNAS](/img/block-rna/astypes_1.png)\n:::\n\n::: {.column width=\"50%\"}\nThere are other types of alternative splicing besides skipped exons. In\neach case, $\\psi$ is defined as the fraction of transcript in which the\nwhite sequence is included.\n\nSince we have already determined where in the genome RNAseq reads came\nfrom using `STAR`, we will now use `rMATS` to take those locations and\ncombine it with information about the locations of alternative exons to\nquantify the inclusion of each alternative exon.\n:::\n:::\n\n## Running rMATS {.smaller}\n\nTo quantify alternative splicing, `rMATS` needs two things: the\nlocations of the reads in the genome (bam files) and the locations of\nalternative exons in the genome (GTF annotation file).\n\n> Note: You may remember that when we ran STAR, we used a different type\n> of genome annotaiton file: GFF. GTFs and GFFs contain essentially the\n> same information and it is possible to interconvert between the two. I\n> chose to introduce you to GFFs because, to my mind, they are more\n> intuitive to and readable by humans. STAR could handle both GTF and\n> GFF formats. rMATS requires GTFs.\n\nHere are the most relevant options when running `rMATS`. See the\ndocumentation\n[here](https://github.com/Xinglab/rmats-turbo/blob/v4.1.0/README.md).\n\n-   **--b1** /path/to/b1.txt (path to a text file that contains paths to\n    all BAM files for samples in condition 1)\n-   **--b2** /path/to/b2.txt (path to a text file that contains paths to\n    all BAM files for samples in condition 2)\n-   **--gtf** /path/to/gtf (path to the gtf genome annotation)\n-   **-t** readtype (single or paired)\n-   **--readlength** readlength\n-   **--od** /path/to/output (output directory)\n\n## Looking at rMATS output {.smaller}\n\nIn this example, the authors were interested in the splicing regulatory\nactivity of the RNA-binding protein RBFOX2. They sequenced RNA from\ncells that had been treated with either shRNA against RBFOX2 or a\ncontrol, non-targeting shRNA. Each condition was performed in\nquadruplicate, meaning we have 4 replicates for each condition. I\ndownloaded their data, aligned it against the mouse genome using `STAR`,\nand then quantified alternative splicing using `rMATS`.\n\nWe won't run `rMATS` here because we would need multiple large bam files\nto do anything meaningful, and honestly, it's just copying things from\nthe documentation and putting them into the command line. What we will\ndo though, is look at the output produced by `rMATS`.\n\n## rMATS output {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\nYou can see that there are many files here, and that each type of\nalternative splicing (A3SS, A5SS, MXE, RI, and SE) has files associated\nwith it. Specifically each event type has 2 files: one that ends in\n'JC.txt' and one that ends in 'JCEC.txt'. The 'JC.txt' files only use\nreads that cross splice junctions to quantify splicing (JC = junction\ncounts) while the 'JCEC.txt' files use both junction reads *and* reads\nthat map to the alternative exon (EC = exon counts). We are going to use\nthe files ending in `*JC.txt`.\n:::\n\n::: {.column width=\"50%\"}\n![](/img/block-rna/rmats_dir.png)\n:::\n:::\n\n## rMATS output {.smaller}\n\n::: columns\n::: {.column width=\"40%\"}\nIf we look at `SE.MATS.JC.txt` file the column names are at the top.\nLet's go through some of the more important columns:\n\n-   **ID** A unique identifier for this event.\n-   **chr** chromosome\n-   **strand** strand (+ or -)\n-   **exonStart_0base** the coordinate of the beginning of the\n    alternative exon (using 0-based coordinates)\n-   **exonEnd** the coordinate of the end of the alternative exon\n:::\n\n::: {.column width=\"60%\"}\n![](/img/block-rna/rmats_out.png)\n:::\n:::\n\n## rMATS output {.smaller}\n\n::: columns\n::: {.column width=\"40%\"}\n-   **upstreamES** the coordinate of the beginning of the exon\n    immediately upstream of the alternative exon\n-   **upstreamEE** the coordinate of the end of the exon immediately\n    upstream of the alternative exon\n-   **downstreamES** the coordinate of the beginning of the exon\n    immediately downstream of the alternative exon\n-   **downstreamEE** the coordinate of the end of the exon immediately\n    downstream of the alternative exon\n:::\n\n::: {.column width=\"60%\"}\n![](/img/block-rna/rmats_out.png)\n:::\n:::\n\n## rMATS output {.smaller}\n\nNotice that with these coordinates and the sequence of the genome, you\ncould derive the sequences flanking each of these exons. That could be\nuseful, perhaps, if you wanted to ask if there were short sequences\n(kmers) enriched near exons whose inclusion was sensitive to RBFOX2 loss\nversus exons whose inclusion was insensitive.\n\n-   **IJC_SAMPLE_X** the number of read counts that support inclusion of\n    the exon is sample X (four numbers, one for each replicate, each\n    separated by a comma)\n-   **SJC_SAMPLE_X** same thing, but for read counts that support the\n    exclusion of the exon\n\n## rMATS output {.smaller}\n\nThe numbers from `[S|I]JC_SAMPLE_X` could be useful for filtering events\nbased on coverage. Say, for example, that we were looking at an event\nthat when we combined IJC and SJC counts for each replicate we got\nsomething like 2,4,1,5. That would mean that in the replicates for this\ncondition, we only had 2, 4, 1, and 5 reads that tell us anything about\nthe status of this exon. That's pretty low, so I would argue that we\nreally wouldn't want to consider this event at all since we don't have\nmuch confidence that we know anything about its inclusion.\n\n-   **PValue** The pvalue asking if the PSI values for this event\n    between the two conditions is statistically significantly different\n-   **FDR** The p value, after it has been corrected for multiple\n    hypothesis testing. This is the significance value you would want to\n    filter on.\n-   **IncLevel1** PSI values for the replicates in condition 1 (in this\n    case, condition 1 is RBFOX shRNA).\n-   **IncLevel2** PSI values for the replicates in condition 2 (in this\n    case, condition 2 is Control shRNA).\n-   **IncLevelDifference** Difference in PSI values between conditions\n    (Condition 1 - Condition 2).\n\n## rMATS output {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsis <- read.table(here(\"data/block-rna/rMATS/SE.MATS.JC.txt.gz\"), header = T) %>%\n  #Get rid of columns we aren't really going to use.\n  dplyr::select(., c('ID', 'geneSymbol', 'IJC_SAMPLE_1', 'SJC_SAMPLE_1', 'IJC_SAMPLE_2', 'SJC_SAMPLE_2', 'FDR', 'IncLevel1', 'IncLevel2', 'IncLevelDifference'))\n\nhead(psis)\n```\n:::\n\n\nWe will only consider events where there are *at least* 20 informative\nreads that tell us about the inclusion of the exon `IJC + SJC > 20` in\n**every replicate**. For example, for event '5' (gene Neil1) above,\nSample 1 replicates have 12, 6, 9, and 5 reads while Sample 2 replicates\nhave 10, 8, 14, and 0 reads. I would want to require that all of 12, 6,\n9, 5, 10, 8, 14, and 0 are greater than 20 in order to worry about this\nevent. Otherwise, I conclude that we don't have enough data to\naccurately conclude anything about this event.\n\n## tidy rMATS output {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsis <- psis %>%\n  #Split the replicate read counts that are separated by commas into different columns\n  separate(., col = IJC_SAMPLE_1, into = c('IJC_S1R1', 'IJC_S1R2', 'IJC_S1R3', 'IJC_S1R4'), sep = ',', remove = T, convert = T) %>%\n  separate(., col = SJC_SAMPLE_1, into = c('SJC_S1R1', 'SJC_S1R2', 'SJC_S1R3', 'SJC_S1R4'), sep = ',', remove = T, convert = T) %>%\n  separate(., col = IJC_SAMPLE_2, into = c('IJC_S2R1', 'IJC_S2R2', 'IJC_S2R3', 'IJC_S2R4'), sep = ',', remove = T, convert = T) %>%\n  separate(., col = SJC_SAMPLE_2, into = c('SJC_S2R1', 'SJC_S2R2', 'SJC_S2R3', 'SJC_S2R4'), sep = ',', remove = T, convert = T)\n\nhead(psis)\n```\n:::\n\n\n## filter rMATS output {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthresh <- ??\n\npsis_filt <- psis %>%\n  mutate(., S1R1counts = ?? + ??) %>%\n  mutate(., S1R2counts = ?? + ??) %>%\n  mutate(., S1R3counts = IJC_S1R3 + SJC_S1R3) %>%\n  mutate(., S1R4counts = IJC_S1R4 + SJC_S1R4) %>%\n  mutate(., S2R1counts = ?? + ??) %>%\n  mutate(., S2R2counts = ?? + ??) %>%\n  mutate(., S2R3counts = IJC_S2R3 + SJC_S2R3) %>%\n  mutate(., S2R4counts = IJC_S2R4 + SJC_S2R4) %>%\n  #Filter on read counts\n  filter(., S1R1counts >= thresh & S1R2counts >= thresh & S1R3counts >= thresh & S1R4counts >= thresh &\n           S2R1counts >= thresh & S2R2counts >= thresh & S2R3counts >= thresh & S2R4counts >= thresh)\n\nhead(psis_filt)\n```\n:::\n\n\n## Plot distribution of PSI values {.smaller}\n\nExons whose inclusion is not regulated tend to have PSI values that are\neither very close to 0 or very close to 1 (i.e. these exons are pretty\nmuch always included or always skipped). Exons whose inclusion is\nregulated tend to have PSI values that are more evenly spread between 0\nand 1. Do see this in our data?\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\npsis_filt_psi <- psis_filt %>%\n  #Separate psi value replicates into individual columns\n  separate(., col = ??, into = c('PSI_S1R1', 'PSI_S1R2', 'PSI_S1R3', 'PSI_S1R4'), sep = ',', remove = T, convert = T) %>%\n  separate(., col = ??, into = c('PSI_S2R1', 'PSI_S2R2', 'PSI_S2R3', 'PSI_S2R4'), sep = ',', remove = T, convert = T) %>%\n  #Select the columns we want\n  dplyr::select(., c(contains('PSI'), FDR))\n\n#Turn data from wide format into long format for plotting purposes\n\npsis_filt_psi_long <- gather(psis_filt_psi,\n                             key = sample,\n                             value = psi,\n                             PSI_S1R1:PSI_S2R4) %>%\n  #For each row, mark whether that replicate came from Condition 1 (RBFOXkd) or Condition2 (Controlkd)\n  #We can tell that by asking if the substring 'S1' is somewhere in 'sample'\n  mutate(., condition = ifelse(grepl('S1', sample), 'RBFOX2kd', 'Controlkd')) %>%\n  #Make a column indicating whether the FDR in this row is significant\n  mutate(., sig = ifelse(FDR < 0.05, 'yes', 'no'))\n\n#Plot\ncolors <- c('DarkOrange', 'DarkViolet')\n\nggplot(psis_filt_psi_long,\n       aes(x = ??, linetype = ??, color = sig)) +\n  geom_density() +\n  theme_cowplot() +\n  facet_wrap(~sig, scales = \"free_y\", nrow = 2) +\n  scale_color_manual(values = colors)\n```\n:::\n\n\n## PCA of PSI values {.smaller}\n\nJust as we did with gene expression values, we can monitor the quality\nof this data using principle components analysis. We would expect that\nreplicates within a condition would be clustered next to each other in\nthis analysis and that PC1, the principal component along which the\nmajority of the variance lies, would separate the conditions.\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\n#Make a matrix of psi values\npsis.matrix <- dplyr::select(psis_filt_psi, -??) %>% na.omit(.)\n\n#Use prcomp() to derive principle component coordinants of PSI values\npsi.pca <- prcomp(t(psis.matrix))\n\n#Add annotations of the conditions to the samples\npsi.pca.pc <- data.frame(psi.pca$x, sample = colnames(psis.matrix)) %>%\n  mutate(., condition = ifelse(grepl('S1', sample), 'RBFOX2kd', 'Controlkd'))\n\n#Get the amount of variances contained within PC1 and PC2\npsi.pca.summary <- summary(psi.pca)$importance\npc1var = round(psi.pca.summary[2,1] * 100, 1)\npc2var = round(psi.pca.summary[2,2] * 100, 1)\n\n#Plot PCA data\nggplot(psi.pca.pc, aes(x = ??, y = ??, shape = ??, color = ??)) +\n  geom_point(size = 5)  +\n  scale_color_manual(values = colors) +\n  xlab(paste('PC1,', pc1var, '% explained var.')) +\n  ylab(paste('PC2,', pc2var, '% explained var.')) +\n  theme_cowplot()\n```\n:::\n\n\n## heatmap of psi events\n\n\n::: {.cell output-location='slide'}\n\n```{.r .cell-code}\n# Filter only significant events\npsi_sig <- psis_filt_psi %>%\n  filter(?? < 0.05) %>%\n  select(-??)\n\n# row scaled heatmap\npheatmap(mat = psi_sig,\n         clustering_method = \"ward.D2\",\n         scale = \"??\",\n         show_rownames = F\n          )\n```\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}