{
  "hash": "d050111948665b4daa4b012635a1ac82",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"DNA Block - Problem Set 19\"\nformat:\n  html:\n    embed-resources: true\n    code-fold: true\nexecute:\n  echo: true\n---\n\n## Problem Set\n\nTotal points: 20.\n\nFor this problem set, you will explore the relationship between\n\n## Load libraries\n\nStart by loading libraries you need analysis in the code chunk below.\n\n\n::: {.cell}\n\n:::\n\n\nLoad the data from the MNase-seq experiment.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmnase_tbl <- read_bed(___)\n```\n:::\n\n\nIn class we learned that MNase digestion yields nucleosomal \"footprints\" of \\~150 bp in size. I've added blue vertical lines to emphasize positions of the major peak (intact nucleosomes) as well as smaller \"sub-nucleosomal\" peak.\n\n![](img/ps-17-mnase-histogram.png)\n\nWe can calculate the counts for the histogram above and more precisely determine the maximum signal using `which.max()` to identify the *index* of the maximum value in a vector (*not* the value itself!):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrag_hist <-\n  mnase_tbl |>\n  mutate(frag_len = ___) |>\n  count(frag_len)\n\n# `which.max` takes a vector and gives us the index of the maximum value\nmax_idx <- which.max(___)\n\n# now we can use that index to find the most abundant fragment size\nncp_max <- frag_hist$frag_len[max_idx]\n```\n:::\n\n\nSo this tells us that that the most abundant fragment size in the library is ** ___ *** bp.\n\n## Question 1\n\nLet's take a closer look at the some of the smaller fragments in the MNase experiment. In particular, let's zoom in on the populations of fragments that are smaller than 1 nucleosome in size, the peak between 85 and 95 bp (the left-most blue vertical line).\n\n1.  Use the above strategy to precisely determine the peak of this smaller size range. How big are those fragments? These are called \"sub-nucleosomal\" fragments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrag_hist_sub <- filter(\n  frag_hist,\n  ___\n)\n\nn_max_sub <- which.max(___)\n# use the strategy above to identify the position of maximum signal\nsubnuc_max <- ___\n```\n:::\n\n\n**Answer:**\n\nThe maximum size of sub-nucleosomal fragments is at ___ bp.\n\n2.  Do this one more time, and identify the position of maximum signal in the disome peak (i.e., the fragments protected by two nucleosomes).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfrag_hist_di <- filter(\n  frag_hist,\n  ___\n)\n\nn_max_di <- which.max(___)\ndinuc_max <- ___\n```\n:::\n\n\n3.  Recreate the histogram using ggplot2 (using relevant code from class 17) and\n    add the blue vertical lines at the peak positions you calculated,\n    including the position of the disomes above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  mnase_tbl,\n  aes(x = ___)\n) +\n  geom_histogram(\n    # single base-pair resolution\n    binwidth = ___\n  ) +\n  labs(\n    x = \"___\",\n    title = \"___\"\n  ) +\n  theme_cowplot() +\n  geom_vline(\n    xintercept = ___,\n    color = \"blue\"\n  )\n```\n:::\n\n\n## Question 2 -- 13 points\n\nNext we're going to look at *where* these sub-sucleosomes are with respect to\nintact nucleosomes.\n\nOur strategy will be to compare the density of sub-nucleosomes relative to\nthe mid-points of previously mapped nucleosomes. Specifically, our reference point will be the midpoints of the +1 nucleosomes.\n\nSo you'll make a metaplot, but instead of using transcription start sites as the reference point, we'll use the midpoints of the +1 nucleosome, and instead of MNase-seq signal density, you'll count up the number of individual reads that intersect with windows around those midpoints.\n\n1.  First, load the relevant data. We'll re-use the `yeast_mnase_chrII.bed.gz` data you loaded above, plus you'll need to load two other files:\n\n    -   a \"genome\" file, `sacCer3.chrom.sizes`\n    -   a BED file, `yeast_p1_chrII.bed.gz` which contains the mid-points of the +1 nucleosomes on chromosome 2. Recall that the +1 nucleosome is the nucleosome downstream of the transcription start site.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenome <- read_genome(___)\n\np1_tbl <- read_bed(___)\n```\n:::\n\n\n2.  Next, we need the mid-points of nucleosomes for comparison. The following function needs fixing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_mids <- function(tbl, min_len, max_len) {\n  tbl |>\n    mutate(\n      frag_len = ___\n    ) |>\n    filter(\n      ___\n    ) |>\n    mutate(\n      midpoint = ___\n    ) |>\n    select(chrom, midpoint) |>\n    rename(start = midpoint) |>\n    mutate(end = start + 1)\n}\n```\n:::\n\n\n3.  Now use this function to calculate the midpoints of the intact nucleosome fragments (around 149 bp) and the sub-nucleosomal fragments (around 90 bp). Expand these midpoints by 20 bp on either side using `bed_slop()`, since we'll be looking for intersections with these intervals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nncp_mids_tbl <-\n  # specify the min and the max sizes, expanding out from the max size 3 bp in each direction to capture the peak\n  calc_mids(mnase_tbl, ___, ___) |>\n  # now expand out by 20 bp on either side\n  bed_slop(___, ___)\n\nsubnuc_mids_tbl <-\n  calc_mids(mnase_tbl, ___, ___) |>\n  bed_slop(___, ___)\n```\n:::\n\n\n4.  Next, we need to make the intervals for the metaplot. We'll look 100 bp up- and downstream of the +1 nucleosome positions, and make windows that are **1 bp** in size.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1_win_tbl <-\n  bed_slop(\n    p1_tbl,\n    ___,\n    ___\n  ) |>\n  bed_makewindows(\n    ___\n  )\n```\n:::\n\n\n5.  Almost there! Now you just need to identify the number of short and long nuclesome fragments (based on their midpoints) that intersect with the +1 nucleosomes you defined above.\n\n    Use `bed_intersect()` to identify fragments that overlap, and then just count the number of fragments per `.win_id` (don't forget the .`.x` suffix). Note you will do this separately for the short and long fragments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nncp_mids_summary_tbl <-\n  bed_intersect(\n    p1_win_tbl,\n    ncp_mids_tbl\n  ) |>\n  count(.win_id.x) |>\n  mutate(type = \"Intact nucleosomes (~149 bp)\")\n\nsubnuc_mids_summary_tbl <-\n  bed_intersect(\n    p1_win_tbl,\n    subnuc_mids_tbl\n  ) |>\n  count(.win_id.x) |>\n  mutate(type = \"Sub-nucleosomes (~90 bp)\")\n```\n:::\n\n\n6.  The following joins the tables you made together, and makes the x-axis more informative, by converting to position rather than window ID.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwin_ids <- seq(-100, 100, 1)\n\nall_tbl <- bind_rows(\n  ncp_mids_summary_tbl,\n  subnuc_mids_summary_tbl\n) |>\n  mutate(win_ids = win_ids, .by = \"type\")\n```\n:::\n\n\n7.  Finally, we plot the data with position on the x-axis, and count on the y-axis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(\n  all_tbl,\n  aes(x = win_ids, y = n)\n) +\n  # add a line representing nucleosome density\n  geom_line(\n    linewidth = 1,\n    color = \"red\"\n  ) +\n  # facet by type of fragment\n  facet_wrap(\n    ~type,\n    scales = \"free_y\"\n  ) +\n  theme_minimal_grid() +\n  labs(\n    x = \"Position relative to +1 nucleosome midpoints\",\n    y = \"Number of intersecting fragments\",\n    title = \"Fragment density around +1 nucleosome midpoints\"\n  )\n```\n:::\n\n\nYour plot should look like this:\n\n![](img/ps-17-nucleosome-histograms.png)\n\n## Interpretation\n\nHow do you interpret these plots?\n\nRationalize the pattern for intact nucleosomes. What pattern did you expect to see?\n\n**Answer:**\n\nRationalize the pattern for sub-nucleosome. How would you describe the positions of sub-nucleosomal fragments, relative to the +1 nucleosome midpoints? What might this mean with respect to gene transcription?\n\n**Answer:**\n\nWhat do the differences between signal magnitudes (reflected by the y-axis) mean?\n\n**Answer:**\n\n## Submit\n\nBe sure to click the \"Render\" button to render the HTML output. Then paste the URL of this Posit Cloud project into the problem set on Canvas.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}