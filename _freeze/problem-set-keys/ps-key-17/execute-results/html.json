{
  "hash": "9cfbafb959b0648d418a759ffc95b28e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"DNA Block - Problem Set 17\"\nformat:\n  html:\n    code-fold: true\n    embed-resources: true\n---\n\n## Problem Set\n\nYou have two tasks for this problem set.\n\nEach problem below is worth **20 points**.\n\n## Setup\n\nLoad libraries you'll need for analysis below. You'll need the `tidyverse` and `valr` packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(valr)\n```\n:::\n\n\n## Question 1 -- 5 points\n\nWe'll work with a few different files for the next questions.\n\n- `hg19.refGene.chr22.bed.gz` is a BED12 file containing RefSeq gene (mRNA) information for chr22.\n- `hg19.rmsk.chr22.bed.gz` is a BED6 containing repetitive elements in the human genome.\n- `hg19.dnase1.bw` is a bigWig file containing DNaseI signal.\n\nYou can find the path to each with `valr_example()`. Load each one invdividually using the `read_*` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_tbl <- read_bed(\n  valr_example(\"hg19.refGene.chr22.bed.gz\")\n)\n\nrmsk_tbl <- read_bed(\n  valr_example(\"hg19.rmsk.chr22.bed.gz\")\n)\n\ndnase_tbl <- read_bigwig(\n  valr_example(\"hg19.dnase1.bw\")\n)\n```\n:::\n\n\nSome valr functions require a \"genome\" file, which is just a tibble of chromosome names and sizes.\n\nThe hg19 genome file is available at `valr_example(\"hg19.chrom.sizes.gz\")`. Use `read_genome()` to load it.\n\nInspect the genome tibble. How many columns does it have? What is the largest chromosome?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenome <- read_genome(\n  valr_example(\"hg19.chrom.sizes.gz\")\n)\n\nlargest_chrom <-\n  arrange(genome, desc(size)) |>\n  pull(chrom) |>\n  head(1)\n```\n:::\n\n\n**Answers:**\n\nThere are **2** columns in the genome tibble and the largest chromosome is **chr1**.\n\n## Question 2 -- 5 points\n\nWhich repeat class covers the largest amount of chromosome 22? You\nneed to calculate the sum of the sizes of all intervals in each repeat class.\n\nA common pattern for this is e.g. `arrange(desc(size))`+ `pull(name)` + `head(1)`.\n\nYou could also use `slice_max(size, n = 1))` + `pull(name)` + `head(1)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrpt_coverage_tbl <-\n  rmsk_tbl |>\n  mutate(\n    interval_size = end - start\n  ) |>\n  summarize(\n    total_size = sum(interval_size),\n    .by = name\n  )\n\nrpt_high_cov <- rpt_coverage_tbl |>\n  arrange(desc(total_size)) |>\n  pull(name) |>\n  head(1)\n\n# or this way, don't need to arrange first\nrpt_high_cov <- rpt_coverage_tbl |>\n  slice_max(total_size, n = 1) |>\n  pull(name) |>\n  head(1)\n```\n:::\n\n\n**Answer:**\n\nThe repeat class with the highest coverage is ALR/Alpha.\n\n## Question 3\n\nWhich promoter has the highest DNase I accessibility?\n\n1. Use the `create_tss()` function to generate transcription start sites from\n   the refGene annotations. How big are these intervals?\n\n2. Generate promoter regions with `bed_slop()`, adding 500 bp up- and downstream\n   of the TSS. `bed_slop()` requires the genome file above.\n\n3. Use `bed_map()` to calculate the total (i.e., summed) DNase I signal in the\n   promoters (the `score` column in the DNase file).\n\nWhich gene has the highest DNase I in the region you defined above?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntss_tbl <- create_tss(gene_tbl)\n\npromoter_tbl <- bed_slop(\n  tss_tbl,\n  genome,\n  both = 500\n)\n\npromoter_dnase_tbl <-\n  bed_map(\n    promoter_tbl,\n    dnase_tbl,\n    score_sum = sum(value)\n  ) |>\n  replace_na(list(score_sum = 0))\n\ngene_high_dnase <-\n  promoter_dnase_tbl |>\n  arrange(desc(score_sum)) |>\n  pull(name) |>\n  head(1)\n```\n:::\n\n\n**Answer:**\n\nThe gene with the highest DNase I signal in its promoter is NR_001591.\n\n## Question 4\n\n**Is DNase I accessibility in promoters significantly higher than expected by chance?**\n\n1. Calculate the mean DNase I signal across all promoters from **Question 3**.\n\n1. Use `bed_shuffle()` to generate 1000 random intervals of the same size as your promoters.\n   You'll need to provide the genome file from above.\n\n1. Use `bed_map()` to calculate DNase I signal in these random regions.\n\n1. Calculate what fraction of random regions have mean DNase I signal greater than\n   or equal to your observed promoter mean. This is your empirical p-value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate observed mean DNase I signal across all promoters\nobserved_mean <- mean(promoter_dnase_tbl$score_sum, na.rm = TRUE)\n\n# Generate 1000 random intervals and calculate their DNase I signals\nset.seed(42)\nn_permutations <- 1000\n\nrandom_signals <- map_dbl(\n  1:n_permutations,\n  \\(x) {\n    # Shuffle promoter intervals to random positions\n    random_intervals <- bed_shuffle(promoter_tbl, genome)\n\n    # Calculate DNase I signal in random regions\n    random_dnase <- bed_map(\n      random_intervals,\n      dnase_tbl,\n      score_sum = sum(value)\n    ) |>\n      replace_na(list(score_sum = 0))\n\n    # Return mean signal for this permutation\n    mean(random_dnase$score_sum, na.rm = TRUE)\n  }\n)\n\n# Count how many random signals are >= observed mean\n#\n# `random_signals >= observed_mean` is a vector of TRUE/FALSE values\nn_extreme <- sum(random_signals >= observed_mean)\n\n# Calculate empirical p-value as proportion\nempirical_p <- n_extreme / length(random_signals)\n```\n:::\n\n\n**Answer:**\n\nThe observed mean DNase I signal in promoters is 0.728, the mean of random signals is 0.003, and the empirical p-value is 0.001, so DNase I accessibility in promoters is significantly higher than expected by chance.\n\n## Submit\n\nBe sure to click the \"Render\" button to render the HTML output.\n\nThen paste the URL of this Posit Cloud project into the problem set on Canvas.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}