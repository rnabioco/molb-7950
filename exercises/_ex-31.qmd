---
title: "Single cell RNA-seq class I"
author: "Kent Riemondy"
---

```{r}
#| label: load-libs
#| message: false
#| warning: false
#| echo: false
library(here)
library(scran)
library(scater)
library(SingleCellExperiment)
library(DropletUtils)
library(tximport)
library(Matrix)
library(AnnotationHub)
library(eds)
```

# Overview

Today we will begin a two-course segment on single cell RNA-seq analysis. We will begin with an introduction to single cell RNA-seq data, followed by a discussion of key quality control metrics used to exclude low-quality cells from the data. 

### Analyzing single cell data in R

Droplet based scRNA-seq will produce libraries with 100,000 - 1,000,000 cell barcodes in each experiment, despite only 1-10,000 cells being loaded. Many of these barcodes are generated by non-cell containing empty droplets, which will end up with a few reads.

Storing a matrix of 20,000 genes x 1,000,000 cell barcodes would require a large amount of memory (20 billion values). However most of these values (> 95%) are zeros due to many empty barcodes with few UMIs and the low efficiency of single cell library generation (< 10-20% efficient). To limit unnecessary memory usage single cell data matrices are stored in a `sparseMatrix` format.

```{r}
# typical dense matrix format
vals <- c(
  0, 0, 0, 2, 0,
  0, 1, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 1,
  0, 0, 0, 0, 0
)

m <- matrix(vals, nrow = 5)
m
```

Converting a dense matrix to a sparse matrix can be accomplished using the generic `as` function (which is a common way to convert formats). 

```{r}
sm <- as(m, "sparseMatrix")
# alternatively
# Matrix(vals, nrow = 5)
sm
```

The sparse matrix format only stores non-zero values in the matrix. Internally , and in text formats, these are stored as a row column value triplet. 

```{r}
summary(sm)
```

Many of the functions that manipulate matrices (e.g. `rowMeans`, `colSums`, `apply`, `[`) can also be used on sparseMatrices, provided that you load the `Matrix` package (e.g `library(Matrix)`).


How can we extract the first 2 rows and first 3 columns of the sparse matrix `sm` that we generated above?

```{r}
#| eval: false
# print subset of sm
sm[1:2, 1:3]
```

How can we calculate the sum of the columns of `sm`?

```{r}
#| eval: false
# find column sums of sparse
colSums(sm)
```

### Base R subsetting

To work with single cell data it will be helpful to know some base R concepts in such as
subsetting with brackets `[` and referencing and generating columns with `$`.

Vectors in R can be subset by vector index (position), a logical vector (c(TRUE, FALSE)), or name (if the vector is named). 

Consider the following character vector `letters`.

```{r}
letters

# extract 2nd, 4th, and 6th entry
letters[c(2, 4, 6)]

# subset by creating logical vector
vowels <- c("a", "e", "i", "o", "u")
is_a_vowel <- letters %in% vowels

letters[is_a_vowel]

# name the letters vector with uppercase LETTERS
names(letters) <- LETTERS

# subset by name
letters[c("A", "Z")]
```

Matrices are 2 dimensional vectors and have similar subsetting rules except there are two dimensions, rows and columns.

`matrix[rows_to_subset, columns_to_subset]`

```{r}
m <- matrix(1:24, nrow = 6)

# extract 2nd, 4th, and 6th row
m[c(2, 4, 6), ]

# extract 2nd and 4th column
m[, c(2, 4)]

# first 3 rows and 2nd and 4th column
m[1:3, c(2, 4)]

# extract rows with totals > 50
m[rowSums(m) > 50, ]

# extract columns with minimum values < 8
m[, colMins(m) < 8]
```

The base R `data.frame` and Bioconductor `DataFrame` can also be subset with the `[` and we can reference individual vectors in a data.frame using `$`. 

```{r}
# first 3 rows and columns of mtcars data.frame
mtcars[1:3, 1:3]

# columns can be referenced using $, which extracts a vector
mtcars$mpg

# columns can be generated or overwritten using $ with assignment
mtcars$new_column_name <- "Hello!"
mtcars$wt <- mtcars$wt * 1000

# We can subset using logical vectors
# E.g. filter for rows (cars) with mpg > 20
mtcars[mtcars$mpg > 20, ]
```


### Reading alevin output into R with tximport

Our old-friend, the `tximport` package, has methods for importing the binary data from alevin. We need to supply a path to the `quants_mat.gz` file. Note that in contrast to importing data from salmon, tximport only allows 1 file to be loaded. If you want to load multiple samples use iteration approaches (e.g. `lapply`, `purrr::map`, a `for` loop). Also note that the [`eds`](https://bioconductor.org/packages/release/bioc/html/eds.html) package was installed which greatly speeds up the loading of the matrix.

We will load in data from a 10x Genomics scRNA-seq library generated from human periperhal blood mononuclear cells (PMBCS). 

```{r}
#| label: tximport
library(tximport)
tx <- tximport(
  here("data/block-rna/scrna/pbmc/alevin/quants_mat.gz"),
  type = "alevin"
)
names(tx)
```

`tx` is a list with 3 elements, `abundance`, `counts`, and `countsFromAbundance`. Let's look at the counts element

```{r}
mat <- tx$counts
mat[5:10, 1:3]
```

Here you can see that `tx$counts` is a sparse matrix that is genes (rows) by cells (columns).

How many barcodes are in `tx$counts`? How many genes?

```{r}
#| eval: false
# TODO Find number of barcodes and genes in tx$counts
dim(mat)
```

What fraction of the matrix is non-zero? We can use the `nnzero `function from the `Matrix` package check

```{r}
#| eval: false
nnzero(mat) / length(mat) # (length = # of rows X # of columns)
# similarily
sum(mat > 0) / length(mat)
```

## The SingleCellExperiment class

Single cell analysis is centered around the `SingleCellExperiment` data structure, which serves as a single container to store the input data, various transformations (count data, normalized count data, PCA, UMAPs, etc.) and any results that are generated.

![](../img/block-rna/sce.png)

### Creating a SingleCellExperiment object

 A `SingleCellExperiment` object can be created from our sparse matrix using the `SingleCellExperiment()` function.


```{r}
sce <- SingleCellExperiment(list(counts = mat))
sce
```

The `SingleCellExperiment` object stores the gene x cell count matrix within `assays()`.

```{r}
# get list of assays
assays(sce)

# extract single assay
assay(sce, "counts")[1:4, 1:4]
assays(sce)$counts[1:4, 1:4]

# convenience function for counts assay
counts(sce)[1:4, 1:4]
```

## Accessing and storing cell and gene level metadata

As we perform analyses we will accumulate cell-level information, such as quality control metrics, clustering results, and celltype assignments. 
The SingleCellExperiment class stores this data within a data frame called `colData`, which we can access using `colData()`. This is a specialized Bioconductor specific data.frame class (`DataFrame`) which has similar semantics and functionality to a base R data.frame. 


```{r}
# empty right now.
colData(sce)

# add a sample annotation
colData(sce)$cell_source <- "PBMC"

# equivalent approach using $
sce$cell_source <- "PBMC"

colData(sce)
```

The SingleCellExperiment also stores gene-level metadata in a data.frame called `rowData()`. We will use the rowData to store gene ids, symbols, and other information about genes.

```{r}
# empty right now
rowData(sce)
```

# Manipulating and subsetting a SingleCellExperiment

To get familiar with SingleCellExperiment objects let's *calculate the total number of counts in each cell and store these counts in the `colData().*

```{r}
sce$total_counts <- colSums(counts(sce))
```

Next let's calculate *the total number of counts for each gene, summed across cells* and *the number of cells with > 0 counts per gene*, and store both of these values in the rowData(). 
```{r}
rowData(sce)$total_gene_counts <- rowSums(counts(sce))
rowData(sce)$n_cells_expr <- rowSums(counts(sce) > 0)
rowData(sce)
```

We can subset the SingleCellExperiment using the same syntax used to subset base R data.frames and matrices. Note that `dplyr` verbs do not work with `SingleCellExperiment` (see alternative [tidySingleCellExperiment](https://bioconductor.org/packages/release/bioc/html/tidySingleCellExperiment.html)).

```r
data.frame[rows, columns]

sce[genes, cells]
```


```{r}
#| eval: false

# subset to data from first 4 genes and cells
sce[1:4, 1:4]

# subset to cells from PBMC cells
sce[, sce$cell_source == "PBMC"]


genes_to_keep <- c("ENSG00000223972", "ENSG00000210195", "ENSG00000210196")
sce[genes_to_keep, ]

cells_to_keep <- c("ACTATGGAGGTCCCTG", "GCTGCAGTCCGATCTC", "TCTCAGCTCGCCGAAC")
sce[, cells_to_keep]
```


Many additional functions used on data.frames also work on SingleCellExperiment:

`ncol()`: # of cells  
`nrow()`: # of gene  
`dims()`: # of genes and cells  
`rownames()`: rownames in matrices (e.g. genes)  
`colnames()`: colnames in matrices (e.g. cells)   
`cbind()`: combine multiple SingleCellExperiments by column  
`rbind()`: combine multiple SingleCellExperiments by row  

# Storing gene identifier information

You'll notice that our matrix has ensembl gene ids as the rownames (e.g. ENSG00000289576, ENSG00000221539). This is intentional as these identifiers are guaranteed to be unique and are a more stable and reliable identifier than gene symbols (e.g. ACTB, GAPDH). This becomes important if you want to compare to external datasets or ensure that your data can be easily used by others in the future.

These identifiers are useful but not as easy to interpret as gene symbols. Next we will retrieve gene symbols from an `AnnotationHub()` ensembldb resource and store the identifiers in the rowData().

```{r}
ah <- AnnotationHub()
# download ensembl database
ens_db <- ah[["AH113665"]]

gene_names <- mapIds(ens_db,
  keys = rownames(sce),
  keytype = "GENEID",
  column = "SYMBOL"
)

rowData(sce)$gene <- gene_names
rowData(sce)$gene_id <- rownames(sce)
rowData(sce)
```

We'd like to set the rownames of the object to symbols, but some of these are ` `, `NA` or duplicated which will cause problems. `uniquifyFeatureNames()` is a convenience function that will rename gene symbols that are `NA` or duplicated values to the ensembl ID or a combination of gene symbol and ensembl ID.

```{r}
rownames(sce) <- uniquifyFeatureNames(
  rowData(sce)$gene_id,
  rowData(sce)$gene
)
head(rownames(sce))
```

## Quality control and cell filtering  

Now that we have our data in a SingleCellExperiment we will perform some filtering and quality control to remove low expression genes and poor quality cells.
 
Our SingleCellExperiment has `r nrow(sce)` genes in the matrix. Most of these are
not expressed. We want to exclude these genes as they won't provide any useful
data for the analysis. 

```{r}
# exclude genes expressed in fewer than 10 cells (~ 1% of cells)
rowData(sce)$n_cells <- rowSums(counts(sce) > 0)
sce <- sce[rowData(sce)$n_cells >= 10, ]
sce
```

To exclude low-quality cells we will use the following metrics:

* Number of counts per cell barcode
* Number of genes detected per barcode
* The percentage of counts from mitochondrial genes per barcode

A low number of counts, a low number of detected genes, and a high percentage of mitochondrial counts suggests that the cell had a broken membrane and the cytoplasmic mRNA leaked out. Conversely, an abnormally high number of counts and detected genes could indicate the presence of a doublet. See publication for more info ([Classification of low quality cells from single-cell RNA-seq data](https://doi.org/10.1186/s13059-016-0888-1))

To calculate these metrics we can use `addPerCellQCMetrics` from scater. Mitochondrial genes are named with a common "MT-" prefix (e.g. MT-CO2, MT-ATP6, MR-RNR2), which we can use to identify them.

```{r}
# identify subset of genes that are from mitochondrial genome
is_mito <- startsWith(rowData(sce)$gene, "MT-")
sce <- addPerCellQCMetrics(sce, subsets = list(Mito = is_mito))
colData(sce)
```

We can use the `plotColData()` function from scater to plot various metrics (as a ggplot2 object). 

```{r}
plotColData(sce, y = "sum")
```

```{r}
plotColData(sce, y = "detected")
```

```{r}
plotColData(sce, y = "detected", x = "sum", colour_by = "subsets_Mito_percent")
```

```{r}
plotColData(sce, y = "subsets_Mito_percent", x = "sum") +
  labs(x = "# of counts")
```

Also note that you can easily extract the `colData()` as a data.frame to use with ggplot2 for custom plots. To extract additional features, e.g. per cell gene expression, you can use `makePerCellDF()` or `makePerFeatureDF()` from scater.

```{r}
cell_info <- as.data.frame(colData(sce))
ggplot(cell_info, aes(sum, subsets_Mito_percent)) +
  geom_point()
```


Selecting an appropriate cutoff can be somewhat arbitrary, and there is a risk of excluding meaningful cell populations. I suggest starting with lenient cutoffs, then later increasing the stringency after examining the clustering and cell types.  

Let's define high quality cell as those with less than 20% counts from mitocondrial RNAs, greater than 500 genes detected, and greater than 1000 total counts. *How many cells pass these criteria?*

```{r}
pass_qc <- sce$subsets_Mito_percent < 20 & sce$detected > 500 & sce$sum > 1000
sum(pass_qc)
```























Labeling the qc failed cells in plots can be helpful. 

```{r}
sce$pass_qc <- sce$subsets_Mito_percent < 20 & sce$detected > 500 & sce$sum > 1000

plotColData(sce,
  y = "subsets_Mito_percent",
  x = "sum",
  colour_by = "pass_qc"
) +
  labs(x = "# of counts")
```

Lastly we can subset the `SingleCellExperiment` to exclude the low-quality cells. 

```{r}
sce <- sce[, sce$pass_qc]
sce
```

It is often a good idea to save the `SingleCellExperiment` at periodic steps in the analysis. Use `saveRDS()` to store the object as a file, which can later be imported back into R using `readRDS(). `

```{r}
#| eval: false
saveRDS(sce, "path/to/a/file.rds")
```


## Analysis steps revisited

```{r}
#| echo: false
library(DiagrammeR)
#| out-height: '100%'
#| out-width: '100%'
grViz("
digraph workflow {
  graph [layout = dot,
         rankdir = TD]

  node [shape = cicle,
        style = filled,
        fontcolor = black,
        fontname = 'Helvetica']

  # green
  node [fillcolor = '#009E73']
  load [label= 'Import data\ntximport::tximport()\nSingleCellExperiment()\ncounts()']

  # blue
  node [fillcolor = '#56B4E9']
  cell_qc [label = 'QC cells\n addPerCellQCMetrics()\n plotColData()']
  norm [label = 'Normalize UMI counts\nquickCluster()\n computeSumFactors()\n logNormCounts()']

  # yellow
  node [fillcolor = '#F0E442']
  feature [label = 'Identify variable genes\nmodelGeneVarByPoisson()\n getTopHVGs()']
  dim_red [label = 'Dimensionality reduction via PCA \n runPCA()']
  cluster [label = 'Clustering\n clusterCells()']
  viz [label = 'Make 2D-Visualization\nrunUMAP()']

  # blue
  node [fillcolor = '#56B4E9']

  markers [label = 'Discover cell type markers \nscoreMarkers()']
  annot [label = 'Annotate cell types\nclustifyr and SingleR']

  edge [color = black
        fontname = 'Helvetica']

  load -> cell_qc
  cell_qc -> norm
  norm -> feature
  norm -> markers
  feature -> dim_red
  dim_red -> cluster
  dim_red -> viz
  cluster -> markers
  markers -> annot

  edge [color = 'grey'
        style = 'dashed']
  annot -> cell_qc [label = 'Repeat\n as needed']
  annot -> feature
  annot -> dim_red
  annot -> cluster
}")
```

## Normalization

Normalization attempts to correct for technical biases that will distort biological signal in the data. A large source of variation arises due to differences in sequencing depth between cells. This can be seen by performing PCA on the unnormalized counts. We will use `runPCA` from scater to perform PCA. 

```{r}
# set seed for functions with a randomized component
# to obtain the same result each execution
set.seed(20231023)
sce <- runPCA(sce, exprs_values = "counts", name = "count_PCA")
```

```{r}
plotReducedDim(sce, "count_PCA", colour_by = "sum")
```

Note that PC1 is correlated with the total UMI counts (`sum`), meaning that the largest source of variation is related to differences in sequencing depth rather than biological differences between cells. 


```{r}
plot_df <- makePerCellDF(sce, c("count_PCA", "sum"))

ggplot(plot_df, aes(count_PCA.1, sum)) +
  geom_point()
```

To normalize we will use 3 functions from the scran package. The normalization entails crude clustering to group related cells, identifying a cell-specific normalization factor (size factor), then scaling the counts by this factor and log transforming the data (with a pseudocount). The algorithm is described in detail in the following paper and in the R documentation (`?scuttle::computePooledFactors`)

>Lun AT, Bach K, Marioni JC. Pooling across cells to normalize single-cell RNA sequencing data with many zero counts. Genome Biol. 2016 Apr 27;17:75. doi: 10.1186/s13059-016-0947-7. PMID: 27122128; PMCID: PMC4848819.

```{r}
#| warning: false
set.seed(20231023)
clusters <- quickCluster(sce)
sce <- computeSumFactors(sce, clusters = clusters)
sce <- logNormCounts(sce)
```

```{r}
set.seed(20231023)
sce <- runPCA(sce, exprs_values = "logcounts", name = "PCA")
```


```{r}
plotReducedDim(sce, "PCA", colour_by = "sum")
```

```{r}
plot_df <- makePerCellDF(sce, c("PCA", "sum"))
ggplot(plot_df, aes(PCA.1, sum)) +
  geom_point()
```

We can now see that PC1 does not correlate with total UMI counts and now shows some more distinct groups of cells, which will likely be different cell populations. 

